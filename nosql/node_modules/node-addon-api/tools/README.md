---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050563"
---
# <a name="tools"></a>工具

## <a name="clang-format"></a>clang-format

相較於指定的 git-refs，clang-format 檢查工具的設計目的為檢查變更的程式碼。

## <a name="migration-script"></a>移轉指令碼

移轉工具的設計目的是為了減少移轉流程中的重複性工作。 不過，指令碼的目的不在於為您轉換所有項目。 通常需要一些小型修正和主要重建。

### <a name="how-to-use"></a>使用方式

若要執行轉換指令碼，請先確定您的 `node_modules` 目錄中有最新的 `node-addon-api`。
```
npm install node-addon-api
```

然後執行傳遞專案目錄的指令碼
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

完成之後，請對於指令碼遺漏的項目進行重新編譯和偵錯。


### <a name="quick-fixes"></a>快速修正
以下是可以輕鬆地修正的項目清單。
  1. 如果您方法的傳回值未傳回 JavaScript，請將其變更為 void。
  2. 使用 `.` 存取屬性，或叫用 Napi::Object 中的成員函數，而不是 `->`。
  3. `Napi::New(env, value);` to `Napi::[Type]::New(env, value);


### <a name="major-reconstructions"></a>主要重建
`Napi::ObjectWrap` 的實作與 NAN 的實作明顯不同。 `Napi::ObjectWrap` 會取得已包裝物件的指標，並建立 ObjectWrap 建構函式內已包裝物件的參考。 `Napi::ObjectWrap` 也會將包裝物件的執行個體方法與 Javascript 模組產生關聯，而不是與 NAN 之類的靜態方法產生關聯。

因此，如果您在模組中使用 Nan::ObjectWrap，則必須執行下列步驟。

  1. 將 [ClassName]::New 函數轉換為採用 `Napi::CallbackInfo` 的建構函式。 將其宣告為
```
[ClassName](const Napi::CallbackInfo& info);
```
並將其定義為
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
如此一來，`Napi::ObjectWrap` 建構函式會在物件具現化之後叫用，而且 `Napi::ObjectWrap` 可以使用 `this` 指標來建立已包裝物件的參考。

  2. 將您的原始建構函式程式碼移至新的建構函式。 刪除您的原始建構函式。
  3. 在您的類別初始化函數中，利用下列方式與原生方法產生關聯。
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. 在需要將 NAN 中 ObjectWrap (如 `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());`) 解除包裝的函數中，使用 `this` 指標直接作為未包裝的物件，因為每個 ObjectWrap 執行個體都與唯一的物件執行個體相關聯。


如果您在遵循本指南之後仍發現問題，請留下您問題的說明，我們會嘗試加以解決。
