---
ms.openlocfilehash: b8e00448fe7f8445c8e81302b03a852ee0f7e5cc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050828"
---
<a name="aproba"></a>aproba
======

極致輕量的函式引數驗證程式

```
var validate = require("aproba")

function myfunc(a, b, c) {
  // `a` must be a string, `b` a number, `c` a function
  validate('SNF', arguments) // [a,b,c] is also valid
}

myfunc('test', 23, function () {}) // ok
myfunc(123, 23, function () {}) // type error
myfunc('test', 23) // missing arg error
myfunc('test', 23, function () {}, true) // too many args error

```

有效類型包括：

| 類型 | description
| :--: | :----------
| *    | 符合任何類型
| A    | `Array.isArray` OR `arguments` 物件
| S    | typeof == 字串
| N    | typeof == 數字
| F    | typeof == 函式
| O    | typeof == 物件，而且不是類型 A 和 類型 E
| B    | typeof == 布林值
| E    | `instanceof Error` OR `null` **(特殊：請參閱下方)**
| Z    | == `null`

驗證失敗會擲回三種例外狀況類型的其中一種，由 `EMISSINGARG`、`EINVALIDTYPE` 或 `ETOOMANYARGS` 的 `code` 屬性來辨別。

如果您傳遞不正確的類型，則系統會連同 `EUNKNOWNTYPE` 代碼一併擲回。

如果系統發現 **錯誤** 引數，而且不是空值，便會從其餘引數中選用。  換句話說，如果您傳遞 `ESO`，就會有如在 `E|ESO|ZSO` 中使用了無新意的 `E`。

### <a name="but-i-have-optional-arguments"></a>但是，我有引數可選用嗎？！

您可使用管道 `|` 分隔多個簽章，以提供一個以上的簽章。
如果有任何簽章符合引數，則會被視為有效。

例如，假設您想為 `fs.createWriteStream` 寫入簽章。  文件便會據此描述：

```
fs.createWriteStream(path[, options])
```

這會是 `SO|S` 的簽章。  換句話說，這是一個字串和物件，或者單純是一個字串。

現在，如果您參閱完整的 `fs` 文件，將會發現實際路徑也可以是緩衝區。  而且，選項可以作為字串，換句話說：
```
path <String> | <Buffer>
options <String> | <Object>
```

若要重作，您必須完整列舉所有可能的組合，而這會需要 `SO|SS|OO|OS|S|O` 的簽章。  這個不便之處有其功用：在您執行這類動作時提醒您，這會使 API 變得更加複雜。


### <a name="browser-support"></a>瀏覽器支援

這不具有相依性，而且應該在瀏覽器中進行，但會產生繁雜的堆疊追蹤。

### <a name="why-this-exists"></a>為何有這項功能

我需要一個非常簡單的引數驗證程式。 它必須具備兩個特點：

1. 比判斷提示更簡潔且更容易使用

2. 我們不建議您使用 DSL 的無限 bikeshed

這正是為何類型是由單一字元指定，而且不會作為選用引數的原因。 

其並非用於驗證使用者資料。 其專用於判斷函式的介面。

如果您需要進一步驗證，建議您手動寫入驗證程式，或尋求其他資源。

