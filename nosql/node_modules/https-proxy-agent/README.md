---
ms.openlocfilehash: bd96d4c9278b37a2a3626abd3bd91dd20a15e2e1
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050912"
---
<a name="https-proxy-agent"></a>https-proxy-agent
================
### <a name="an-https-proxy-httpagent-implementation-for-https"></a>HTTPS 的 HTTP(S) Proxy `http.Agent` 實作
[![組建狀態](https://github.com/TooTallNate/node-https-proxy-agent/workflows/Node%20CI/badge.svg)](https://github.com/TooTallNate/node-https-proxy-agent/actions?workflow=Node+CI)

此模組提供的 `http.Agent` 實作會連線到指定的 HTTP 或 HTTPS Proxy 伺服器，並可搭配內建的 `https` 模組使用。

具體來說，這項 `Agent` 實作會連線至中繼「Proxy」伺服器，並藉由核發 [CONNECT HTTP 方法][CONNECT]告知 Proxy 向目的地伺服器開放直接 TCP 連線。

由於這個代理程式會實作 CONNECT HTTP 方法，因此也適用於其他透過 Proxy 連線時會使用這個方法的通訊協定 (例如 WebSocket)。
如需更多相關資訊，請參閱下方的「範例」一節。


<a name="installation"></a>安裝
------------

使用 `npm` 安裝：

``` bash
$ npm install https-proxy-agent
```


<a name="examples"></a>範例
--------

#### <a name="https-module-example"></a>`https` 模組範例

``` js
var url = require('url');
var https = require('https');
var HttpsProxyAgent = require('https-proxy-agent');

// HTTP/HTTPS proxy to connect to
var proxy = process.env.http_proxy || 'http://168.63.76.32:3128';
console.log('using proxy server %j', proxy);

// HTTPS endpoint for the proxy to connect to
var endpoint = process.argv[2] || 'https://graph.facebook.com/tootallnate';
console.log('attempting to GET %j', endpoint);
var options = url.parse(endpoint);

// create an instance of the `HttpsProxyAgent` class with the proxy server information
var agent = new HttpsProxyAgent(proxy);
options.agent = agent;

https.get(options, function (res) {
  console.log('"response" event!', res.headers);
  res.pipe(process.stdout);
});
```

#### <a name="ws-websocket-connection-example"></a>`ws` WebSocket 連線範例

``` js
var url = require('url');
var WebSocket = require('ws');
var HttpsProxyAgent = require('https-proxy-agent');

// HTTP/HTTPS proxy to connect to
var proxy = process.env.http_proxy || 'http://168.63.76.32:3128';
console.log('using proxy server %j', proxy);

// WebSocket endpoint for the proxy to connect to
var endpoint = process.argv[2] || 'ws://echo.websocket.org';
var parsed = url.parse(endpoint);
console.log('attempting to connect to WebSocket %j', endpoint);

// create an instance of the `HttpsProxyAgent` class with the proxy server information
var options = url.parse(proxy);

var agent = new HttpsProxyAgent(options);

// finally, initiate the WebSocket connection
var socket = new WebSocket(endpoint, { agent: agent });

socket.on('open', function () {
  console.log('"open" event!');
  socket.send('hello world');
});

socket.on('message', function (data, flags) {
  console.log('"message" event! %j %j', data, flags);
  socket.close();
});
```

<a name="api"></a>API
---

### <a name="new-httpsproxyagentobject-options"></a>新的 HttpsProxyAgent(Object options)

`HttpsProxyAgent` 類別會實作連線至指定「HTTP(s) Proxy 伺服器」的 `http.Agent` 子類別，藉此通過 Proxy 處理 HTTPS 和/或 WebSocket 要求； 這可以透過使用 [HTTP `CONNECT` 方法][CONNECT]達成。

`options` 引數可以是要使用的 Proxy 伺服器的字串 URI，也可以是有更具體屬性的「options」物件：

  * `host` - 字串 - 要連線的 Proxy 主機 (也可使用 `hostname`)。 必要。
  * `port` - 數值 - 要連線的 Proxy 連接埠。 必要。
  * `protocol` - 字串 - 如果是 `https:`，則使用 TLS 連接至 Proxy。
  * `headers` - 物件 - 要使用 HTTP CONNECT 方法傳送的其他 HTTP 標頭。
  * 所有其他 options 都會傳遞至 `net.connect()`/`tls.connect()` 函式。


<a name="license"></a>授權
-------

(MIT 授權)

Copyright (c) 2013 Nathan Rajlich &lt;nathan@tootallnate.net&gt;

在此免費授與權限給任何取得本軟體副本與相關文件檔案 (以下簡稱「軟體」) 的人員，以供其在不受限制的情況下處理軟體，包括但不限於使用、複製、修改、合併、發佈、散布、再授權及/或銷售軟體副本的權利，以及允許作為軟體提供對象的人員這麼做，但須遵守下列條件：

上述著作權聲明和此權限聲明應包含在「軟體」的所有複本或重要部分中。

軟體係依「現況」提供，不附帶任何形式的明示或默示擔保，包括但不限於商品的適售性或某特定目的之合適性及未侵權。
作者或著作權持有者對於任何索賠、損害或其他責任，均不負任何責任，不論是起因於、出自或連結至軟體或軟體的使用或其他交易所造成的訴訟或合約、侵權或其他事由。

[CONNECT]: http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_Tunneling
