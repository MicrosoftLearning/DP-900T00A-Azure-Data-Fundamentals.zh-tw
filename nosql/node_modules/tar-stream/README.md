---
ms.openlocfilehash: 005b0e7f9a1ee74629126e639e1aeb07226cca3f
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050672"
---
# <a name="tar-stream"></a>tar-stream

tar-stream 僅僅是串流 tar 剖析器和產生器。 它是 streams2，純粹使用資料流運作，也就是說，您可以輕鬆解壓縮/剖析 tarball，而不用進入檔案系統。

請注意，如果您要處理 `.tar.gz` 檔案，則仍需使用 gunzip 指令解壓縮資料。 建議搭配 [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe) 一起使用。

```
npm install tar-stream
```

[![組建狀態](https://secure.travis-ci.org/mafintosh/tar-stream.png)](http://travis-ci.org/mafintosh/tar-stream)
[![授權](https://img.shields.io/badge/license-MIT-blue.svg)](http://opensource.org/licenses/MIT)

## <a name="usage"></a>使用方式

tar-stream 提供兩種串流：建立 tarball 的 [pack](https://github.com/mafintosh/tar-stream#packing)，和解壓縮 tarball 的 [extract](https://github.com/mafintosh/tar-stream#extracting)。 若要[修改現有的 tarball](https://github.com/mafintosh/tar-stream#modifying-existing-tarballs)，請使用兩者。


它能實作 USTAR，並另外支援 pax 延伸標頭。 它應相容於所有常見的 tar 發行版本 (gnutar、bsdtar 等)。

## <a name="related"></a>相關參考

如需將檔案系統上的目錄打包/解包，請前往查看提供檔案系統繫結給此模組的 [tar-fs](https://github.com/mafintosh/tar-fs)。

## <a name="packing"></a>打包

若要建立打包串流，請使用 `tar.pack()` 並呼叫 `pack.entry(header, [callback])` 以新增 tar 項目。

``` js
var tar = require('tar-stream')
var pack = tar.pack() // pack is a streams2 stream

// add a file called my-test.txt with the content "Hello World!"
pack.entry({ name: 'my-test.txt' }, 'Hello World!')

// add a file called my-stream-test.txt from a stream
var entry = pack.entry({ name: 'my-stream-test.txt', size: 11 }, function(err) {
  // the stream was added
  // no more entries
  pack.finalize()
})

entry.write('hello')
entry.write(' ')
entry.write('world')
entry.end()

// pipe the pack stream somewhere
pack.pipe(process.stdout)
```

## <a name="extracting"></a>解壓縮

若要解壓縮串流，請使用 `tar.extract()` 並接聽 `extract.on('entry', (header, stream, next) )`。

``` js
var extract = tar.extract()

extract.on('entry', function(header, stream, next) {
  // header is the tar header
  // stream is the content body (might be an empty stream)
  // call next when you are done with this entry

  stream.on('end', function() {
    next() // ready for next entry
  })

  stream.resume() // just auto drain the stream
})

extract.on('finish', function() {
  // all entries read
})

pack.pipe(extract)
```

tar 封存為依序串流，也就是說，您 **必須** 在取得每個項目的串流時清空該串流，否則主要解壓縮串流將會受到背壓並停止讀取。

## <a name="headers"></a>標題

用於 `entry` 中的標頭物件應包含下列屬性。
大多數的值都可以透過陳述檔案來找到。

``` js
{
  name: 'path/to/this/entry.txt',
  size: 1314,        // entry size. defaults to 0
  mode: 0o644,       // entry mode. defaults to to 0o755 for dirs and 0o644 otherwise
  mtime: new Date(), // last modified date for entry. defaults to now.
  type: 'file',      // type of entry. defaults to file. can be:
                     // file | link | symlink | directory | block-device
                     // character-device | fifo | contiguous-file
  linkname: 'path',  // linked file name
  uid: 0,            // uid of entry owner. defaults to 0
  gid: 0,            // gid of entry owner. defaults to 0
  uname: 'maf',      // uname of entry owner. defaults to null
  gname: 'staff',    // gname of entry owner. defaults to null
  devmajor: 0,       // device major version. defaults to 0
  devminor: 0        // device minor version. defaults to 0
}
```

## <a name="modifying-existing-tarballs"></a>修改現有的 tarball

使用 tar-stream 即可在現有 tarball 中輕鬆重新寫入路徑/變更模式。

``` js
var extract = tar.extract()
var pack = tar.pack()
var path = require('path')

extract.on('entry', function(header, stream, callback) {
  // let's prefix all names with 'tmp'
  header.name = path.join('tmp', header.name)
  // write the new entry to the pack stream
  stream.pipe(pack.entry(header, callback))
})

extract.on('finish', function() {
  // all entries done - lets finalize it
  pack.finalize()
})

// pipe the old tarball to the extractor
oldTarballStream.pipe(extract)

// pipe the new tarball the another stream
pack.pipe(newTarballStream)
```

## <a name="saving-tarball-to-fs"></a>將 tarball 儲存至 fs


``` js
var fs = require('fs')
var tar = require('tar-stream')

var pack = tar.pack() // pack is a streams2 stream
var path = 'YourTarBall.tar'
var yourTarball = fs.createWriteStream(path)

// add a file called YourFile.txt with the content "Hello World!"
pack.entry({name: 'YourFile.txt'}, 'Hello World!', function (err) {
  if (err) throw err
  pack.finalize()
})

// pipe the pack stream to your file
pack.pipe(yourTarball)

yourTarball.on('close', function () {
  console.log(path + ' has been written')
  fs.stat(path, function(err, stats) {
    if (err) throw err
    console.log(stats)
    console.log('Got file info successfully!')
  })
})
```

## <a name="performance"></a>效能

[如需與 node-tar 的效能比較，請參閱 tar-fs](https://github.com/mafintosh/tar-fs/blob/master/README.md#performance)

# <a name="license"></a>授權

MIT
