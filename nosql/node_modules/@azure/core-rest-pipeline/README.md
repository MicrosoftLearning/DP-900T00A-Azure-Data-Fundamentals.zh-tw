---
ms.openlocfilehash: 6f2950dcb9eebd8a8a946f99370300d10624b1c2
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053035"
---
# <a name="azure-core-http-client-library-for-javascript-experimental"></a>適用於 JavaScript 的 Azure 核心 HTTP 用戶端程式庫 (實驗性)

這是 Azure SDK JavaScript 程式庫的核心 HTTP 管線，可在瀏覽器和 Node.js 中運作。 此程式庫主要用於 [AutoRest](https://github.com/Azure/Autorest) (英文) 和 [`autorest.typescript`](https://github.com/Azure/autorest.typescript) (英文) 所產生的程式碼中。

## <a name="getting-started"></a>開始使用

### <a name="requirements"></a>規格需求

### <a name="currently-supported-environments"></a>目前支援的環境

- [LTS 版本的 Node.js](https://nodejs.org/about/releases/)
- Safari、Chrome、Edge 和 Firefox 的最新版本。

如需詳細資訊，請參閱我們的[支援原則](https://github.com/Azure/azure-sdk-for-js/blob/main/SUPPORT.md)。

### <a name="installation"></a>安裝

此套件主要用於已產生的程式碼中，並不提供終端使用者直接取用。

## <a name="key-concepts"></a>重要概念

### <a name="pipelinerequest"></a>PipelineRequest

`PipelineRequest` 用於描述向 HTTP REST 端點提出要求所需的所有資訊。

### <a name="pipelineresponse"></a>PipelineResponse

`PipelineResponse` 用於描述 REST 端點收到 HTTP 要求後所傳回的 HTTP 回應 (本文、標頭、狀態碼)。

### <a name="sendrequest"></a>SendRequest

`SendRequest` 方法是指收到 `PipelineRequest` 後，可非同步傳回 `PipelineResponse` 的方法。

```ts
export type SendRequest = (request: PipelineRequest) => Promise<PipelineResponse>;
```

### <a name="httpclient"></a>HttpClient

`HttpClient` 是指任何可透過以下介面實作 `SendRequest` 方法的物件：

```ts
export interface HttpClient {
  /**
   * The method that makes the request and returns a response.
   */
  sendRequest: SendRequest;
}
```

`HttpClient` 應該要能使用平台專屬機制，向伺服器端點實際提出 HTTP 要求。

### <a name="pipeline-policies"></a>管線原則

`PipelinePolicy` 適用於實作下列介面的簡易物件：

```ts
export interface PipelinePolicy {
  /**
   * The policy name. Must be a unique string in the pipeline.
   */
  name: string;
  /**
   * The main method to implement that manipulates a request/response.
   * @param request The request being performed.
   * @param next The next policy in the pipeline. Must be called to continue the pipeline.
   */
  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;
}
```

這個物件看起來很像 `HttpClient`，但包含原則名稱以及稍微修改過的 `SendRequest` 簽章，能夠有條件地呼叫管線中下一個原則。

您可以將原則的角色視為 `middleware` 的角色，使用 [Express](https://expressjs.com/) 等架構的 NodeJS 開發人員都很熟悉這個概念。

`sendRequest` 實作可以同時轉換連出要求和連入回應：

```ts
const customPolicy = {
  name: "My wonderful policy",
  async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
    // Change the outgoing request by adding a new header
    request.headers.set("X-Cool-Header", 42);
    const result = await next(request);
    if (response.status === 403) {
      // Do something special if this policy sees Forbidden
    }
    return result;
  }
};
```

大多數原則只與要求或是回應相關，但還是有一些例外狀況，例如 [LogPolicy](https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/core/core-rest-pipeline/src/policies/logPolicy.ts) (英文) 便會同時記錄來自要求與回應的資訊。

### <a name="pipelines"></a>Pipelines

`Pipeline` 是用於管理一組 `PipelinePolicy` 物件的物件， 主要功能是確保以一致且可預測的順序執行原則。

原則的使用方式類似於堆疊 (先進後出)，第一個 `PipelinePolicy` 可以比任何其他原則優先修改 `PipelineRequest`，但修改 `PipelineResponse` 時則排最後一位，因此最接近呼叫者。 最後一個原則在修改連出要求時排最後一位，但可以優先處理回應，因此最接近網路。

`Pipeline` 可用於以下介面：

```ts
export interface Pipeline {
  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;
  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];
  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;
  getOrderedPolicies(): PipelinePolicy[];
  clone(): Pipeline;
}
```

如您所見，這個物件可以自由新增或移除原則，而且與 `HttpClient` 鬆散耦合，因此能向伺服器端點實際執行要求。

`Pipeline` 的一大重要概念是依照排序階段將原則分組：

1. 序列化階段
2. 不處於任何階段的原則
3. 還原序列化階段
4. 重試階段

各階段會按照以上順序出現，最先套用序列化原則，最後套用重試原則。 大多數自訂原則都歸類於第二個貯體，且沒有階段名稱。

將原則新增至管線時，您不僅可以指定原則所屬的階段，還能指定原則是否有任何相依性：

```ts
export interface AddPolicyOptions {
  beforePolicies?: string[];
  afterPolicies?: string[];
  afterPhase?: PipelinePhase;
  phase?: PipelinePhase;
}
```

`beforePolicies` 是指新原則必須先執行的原則，`afterPolicies` 則是新原則必須後執行的原則。 依此類推，`afterPhase` 代表只能在指定階段出現後才能執行的原則。

這個語法讓自訂原則建立者使用 `createPipelineFromOptions` 建立管線時，能夠表達他們的原則與 `@azure/core-rest-pipeline` 提供的內建原則之間，有哪些必要關聯性。

實作者想要修改現有 `Pipeline` 時，也能直接依名稱或階段移除原則，而不必使用 `createEmptyPipeline` 建立新管線。 如想在不修改原始管線的前提下重新建立 `Pipeline` 時，`clone` 方法格外實用。

滿足所有其他條件限制後，原則就會按照新增順序來套用。

## <a name="examples"></a>範例

您可在 `samples` 資料夾中查看更多範例。

## <a name="next-steps"></a>後續步驟

您可執行 `rushx test`，以在本機組建和執行測試。 探索 `test` 資料夾，查看公用類別的進階使用方式和行為。

## <a name="troubleshooting"></a>疑難排解

如果您在使用此程式庫時遇到問題，可隨時[提出問題](https://github.com/Azure/azure-sdk-for-js/issues/new)。

## <a name="contributing"></a>參與

如果您希望向此程式庫投稿，請參閱[投稿指南](https://github.com/Azure/azure-sdk-for-js/blob/main/CONTRIBUTING.md)，深入瞭解如何組建與測試程式碼。

![曝光數](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-js%2Fsdk%2Fcore%2Fcore-rest-pipeline%2FREADME.png)
