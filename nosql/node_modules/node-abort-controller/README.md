---
ms.openlocfilehash: ca2cf748b426d17058b55202a60ece01d9e05592
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050688"
---
# <a name="node-abort-controller"></a>node-abort-controller

適用於 Node.JS EventEmitter (事件發射器) 的 AbortController (中止控制器) Polyfill

[![組建狀態](https://dev.azure.com/stfaul/node-abort-controller/_apis/build/status/southpolesteve.node-abort-controller?branchName=master)](https://dev.azure.com/stfaul/node-abort-controller/_build/latest?definitionId=3&branchName=master)

## <a name="usage"></a>使用方式

```js
import fetch from 'node-fetch'
import AbortController from 'node-abort-controller'

const controller = new AbortController()
const signal = controller.signal

await fetch('https:/www.google.com', { signal })

// Abort after 500ms. Effectively a timeout
setTimeout(() => controller.abort(), 500)
```

## <a name="why-would-i-use-this"></a>為什麼要使用此套件？

您可能不需要！ 一般而言，JavaScript 程式碼可以執行的環境有三種：

- 節點
- 新版瀏覽器 (不是 Internet Explorer)
- 舊版瀏覽器 (大多是 Internet Explorer)

就新版 JS API 而言，每種環境理想上都會取得 polyfill：

- 前提是
- 實作需限定於單一平台。

但實務上不容易達成。 如 webpack 和 browserify 等工具非常適合確保內容在所有環境中現成可用。 但上述兩點都相當容易失效。 您十之八九甚至會在不需要的平台上傳送不甚理想的 polyfill。 因此開發人員該怎麼辦？ 如果是以 `fetch` 和 `AbortController` 實作，我能助您一臂之力。 以下為相關指南。

如果您正在建置...

#### <a name="application-running-in-modern-browsers"></a>在新版瀏覽器中執行的應用程式：

恭喜！ 您完全不需要程式庫或 polyfill！ 請關閉此分頁，並解除安裝此套件。

#### <a name="application-running-in-modern-browsers-and-node-such-as-a-server-side-rendered-js-app"></a>在新版瀏覽器和節點中執行的應用程式 (如伺服器端轉譯的 JS 應用程式)：

請使用此套件和 [node-fetch](https://www.npmjs.com/package/node-fetch)。 您最少需要這些工具。

#### <a name="application-supporting-legacy-browsers-and-not-node"></a>支援舊版瀏覽器但不支援節點的應用程式：

請使用 [abort-controller](https://www.npmjs.com/package/abort-controller) 和 [whatwg-fetch](https://www.npmjs.com/package/whatwg-fetch)。 這些是更完整的 polyfill，可適用於所有瀏覽器環境。

#### <a name="application-supporting-legacy-browsers-and-node"></a>支援舊版瀏覽器和節點的應用程式：

請使用 [abort-controller](https://www.npmjs.com/package/abort-controller) 和 [cross-fetch](https://www.npmjs.com/package/cross-fetch)。 與上述相同，但 cross-fetch 將在瀏覽器和 node.js 中充分發揮 polyfill 的功能。

#### <a name="library-being-consumed-by-other-applications-and-using-fetch-internally"></a>為其他應用程式使用並在內部使用 `fetch` 的程式庫：

請使用此套件和 [node-fetch](https://www.npmjs.com/package/node-fetch)。 這是對您的終端使用者而言，最輕量且客觀最佳的組合。 以 Internet Exploer 為目標的應用程式開發人員必須自行實作瀏覽器不支援的 `AbortController` 和 `fetch`。 但您的程式庫將不會對僅以新版瀏覽器為目標的開發人員強制執行不必要的 polyfill。

## <a name="goals"></a>目標

透過上述指南可得知，此程式庫具有一組特定目標：

1. 在 node.js 中提供最輕量的 polyfill
2. 不在任何瀏覽器環境中提供 polyfill

此做法非常適用於內部使用 `fetch` 和 `AbortController`，並以瀏覽器與節點開發人員為目標的程式庫作者。

## <a name="prior-art"></a>現有技術

謝謝 @mysticatea 提供 https://github.com/mysticatea/abort-controller 。 這是很棒的 `AbortController` polyfill，非常適用於許多使用案例。
