---
ms.openlocfilehash: cbc289a6b02d7acb0ad82e3a95bde8846fcff55e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050457"
---
# <a name="node-jws-build-statushttptravis-ciorgbrianloveswordsnode-jws"></a>node-jws [![組建狀態](https://secure.travis-ci.org/brianloveswords/node-jws.png)](http://travis-ci.org/brianloveswords/node-jws)

[JSON Web 簽章](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html)的實作。

這是針對 `draft-ietf-jose-json-web-signature-08` 開發並實作整個規格，**不包含** X.509 憑證鏈結簽署/驗證 (歡迎使用修補檔)。

有同步 (`jws.sign`、`jws.verify`) 和串流 (`jws.createSign`、`jws.createVerify`) API。

# <a name="install"></a>安裝

```bash
$ npm install jws
```

# <a name="usage"></a>使用方式

## <a name="jwsalgorithms"></a>jws.ALGORITHMS

支援的演算法陣列。 下列是目前支援的演算法。

alg 參數值 | 數位簽章或 MAC 演算法
----------------|----------------------------
HS256 | 使用 SHA-256 雜湊演算法的 HMAC
HS384 | 使用 SHA-384 雜湊演算法的 HMAC
HS512 | 使用 SHA-512 雜湊演算法的 HMAC
RS256 | 使用 SHA-256 雜湊演算法的 RSASSA
RS384 | 使用 SHA-384 雜湊演算法的 RSASSA
RS512 | 使用 SHA-512 雜湊演算法的 RSASSA
PS256 | 使用 SHA-256 雜湊演算法的 RSASSA-PSS
PS384 | 使用 SHA-384 雜湊演算法的 RSASSA-PSS
PS512 | 使用 SHA-512 雜湊演算法的 RSASSA-PSS
ES256 | 使用 P-256 曲線和 SHA-256 雜湊演算法的 ECDSA
ES384 | 使用 P-384 曲線和 SHA-384 雜湊演算法的 ECDSA
ES512 | 使用 P-521 曲線和 SHA-512 雜湊演算法的 ECDSA
無 | 未包含數位簽章或 MAC 值

## <a name="jwssignoptions"></a>jws.sign(options)

(同步) 傳回 JSON Web 簽章的標題和承載。

選項：

* `header`
* `payload`
* `secret` 或 `privateKey`
* `encoding` (選擇性，預設為「utf8」)

`header` 必須是具有 `alg` 屬性的物件。 `header.alg` 必須是在 `jws.ALGORITHMS` 中找到的其中一個值。 如需支援的演算法表格，請參閱上方。

如果 `payload` 不是緩衝區或字串，則會使用 `JSON.stringify` 強制轉成字串。

範例

```js
const signature = jws.sign({
  header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  secret: 'has a van',
});
```

## <a name="jwsverifysignature-algorithm-secretorkey"></a>jws.verify(signature, algorithm, secretOrKey)

(同步) 依據簽章是否符合秘密或金鑰，傳回 `true` 或 `false`。

`signature` 是 JWS 簽章。 `header.alg` 必須是在 `jws.ALGORITHMS` 中找到的值。
如需支援的演算法表格，請參閱上方。 `secretOrKey` 是包含 HMAC 演算法祕密，或是 RSA 和 ECDSA 的 PEM 編碼公開金鑰的字串或緩衝區。

請注意，已忽略簽章標題中的 `"alg"` 值。


## <a name="jwsdecodesignature"></a>jws.decode(signature)

(同步) 傳回 JWS 簽章的解碼標題、解碼承載和簽章部分。

傳回具有三個屬性的物件，例如：
```js
{ header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'
}
```

## <a name="jwscreatesignoptions"></a>jws.createSign(options)

傳回新的 SignStream 物件。

選項：

* `header` (必要)
* `payload`
* `key` || `privateKey` || `secret`
* `encoding` (選擇性，預設為「utf8」)

除了 `header` 以外，所有選項都會在事先知道值或資料流時預期有字串或緩衝區，以方便使用。
使用加密的私密金鑰時，`key`/`privateKey`/`secret` 也可能是物件，請參閱[密碼編譯文件][encrypted-key-docs]。

範例：

```js

// This...
jws.createSign({
  header: { alg: 'RS256' },
  privateKey: privateKeyStream,
  payload: payloadStream,
}).on('done', function(signature) {
  // ...
});

// is equivalent to this:
const signer = jws.createSign({
  header: { alg: 'RS256' },
});
privateKeyStream.pipe(signer.privateKey);
payloadStream.pipe(signer.payload);
signer.on('done', function(signature) {
  // ...
});
```

## <a name="jwscreateverifyoptions"></a>jws.createVerify(options)

傳回新的 VerifyStream 物件。

選項：

* `signature`
* `algorithm`
* `key` || `publicKey` || `secret`
* `encoding` (選擇性，預設為「utf8」)

所有選項在事先知道值或資料流時，或是為了方便起見，皆預期為字串或緩衝區。

範例：

```js

// This...
jws.createVerify({
  publicKey: pubKeyStream,
  signature: sigStream,
}).on('done', function(verified, obj) {
  // ...
});

// is equivilant to this:
const verifier = jws.createVerify();
pubKeyStream.pipe(verifier.publicKey);
sigStream.pipe(verifier.signature);
verifier.on('done', function(verified, obj) {
  // ...
});
```

## <a name="class-signstream"></a>類別：SignStream

在完成時發出單一資料事件 (導出簽章) 的 `Readable Stream`。

### <a name="event-done"></a>事件：「完成」
`function (signature) { }`

### <a name="signerpayload"></a>signer.payload

預期 JWS 承載的 `Writable Stream`。 如果您將 `payload` 選項傳遞至建構函式，則 *請勿* 使用。

範例：

```js
payloadStream.pipe(signer.payload);
```

### <a name="signersecretbrsignerkeybrsignerprivatekey"></a>signer.secret<br>signer.key<br>signer.privateKey

`Writable Stream`。 預期 HMAC 的 JWS 秘密，或 ECDSA 和 RSA 的 PrivateKey。 如果您將 `secret` 或 `key` 選項傳遞至建構函式，則 *請勿* 使用。

範例：

```js
privateKeyStream.pipe(signer.privateKey);
```

## <a name="class-verifystream"></a>類別：VerifyStream

這是發出單一資料事件的 `Readable Stream`，不論該簽章是否有效的結果。

### <a name="event-done"></a>事件：「完成」
`function (valid, obj) { }`

`valid` 是布林值，表示簽章是否有效。

### <a name="verifiersignature"></a>verifier.signature

預期有 JWS 簽章的 `Writable Stream`。 如果您將 `signature` 選項傳遞至建構函式，則 *請勿* 使用。

### <a name="verifiersecretbrverifierkeybrverifierpublickey"></a>verifier.secret<br>verifier.key<br>verifier.publicKey

預期有公開金鑰或祕密的 `Writable Stream`。 如果您將 `key` 或 `secret` 選項傳遞至建構函式，則 *請勿* 使用。

# <a name="todo"></a>TODO

* 應該會有一些實用性選項/API 來定義演算法，而不是每次都必須使用 `{ alg: 'ES512' }` 或其他方式來定義標題物件。

* X.509 支援

# <a name="license"></a>授權

MIT

```
Copyright (c) 2013-2015 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format
