---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050699"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **建置** | **相依性** |
|-----------|---------------|
| [![組建狀態](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![相依性狀態](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


[JSON Web 權杖](https://tools.ietf.org/html/rfc7519)的實作。

這是根據 `draft-ietf-oauth-json-web-token-08` 開發， 並運用 [node-jws](https://github.com/brianloveswords/node-jws)。

# <a name="install"></a>安裝

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>移轉注意事項

* [從 v7 到 v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>使用方式

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(非同步) 如果提供回呼，則會以 `err` 或 JWT 呼叫回呼。

(同步) 將 JsonWebToken 以字串傳回。

`payload` 可能是代表有效 JSON 的物件常值、緩衝區或字串。 
> **請注意，** `exp` 或任何其他宣告僅設定承載是否為物件常值。 不會檢查緩衝區或字串承載的 JSON 有效性。

> 如果 `payload` 不是緩衝區或字串，則會使用 `JSON.stringify` 強制轉成字串。

`secretOrPrivateKey` 是字串、緩衝區或物件，其中包含 HMAC 演算法的祕密，或是 RSA 和 ECDSA 的 PEM 編碼格式私密金鑰。 如果是有複雜密碼的私密金鑰，則根據[密碼編譯文件](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format) (英文) 可以使用物件 `{ key, passphrase }`，在此情況下，請務必傳遞 `algorithm` 選項。

`options`:

* `algorithm` (預設：`HS256`)
* `expiresIn`：以秒或描述時間範圍 [zeit/毫秒](https://github.com/zeit/ms)的字串表示。 
  > 例如:`60`、`"2 days"`、`"10h"` 和 `"7d"`。 數值會視為秒數來解譯。 如果使用字串，請務必提供時間單位 (天、小時等)，否則會預設使用毫秒作為單位 (例如將 `"120"` 視為 `"120ms"`)。
* `notBefore`：以秒或描述時間範圍 [zeit/毫秒](https://github.com/zeit/ms)的字串表示。 
  > 例如:`60`、`"2 days"`、`"10h"` 和 `"7d"`。 數值會視為秒數來解譯。 如果使用字串，請務必提供時間單位 (天、小時等)，否則會預設使用毫秒作為單位 (例如將 `"120"` 視為 `"120ms"`)。
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`：如果為 true，正負號函式將會直接修改承載物件。 如果您在承載已套用宣告後，但在編碼成權杖前需要承載的原始參考，這很有用。



> `expiresIn`、`notBefore`、`audience`、`subject` 和 `issuer` 均無預設值。  這些宣告也可以直接提供於承載之中，且各自附隨 `exp`、`nbf`、`aud`、`sub` 和 `iss`，但您 **無法** 同時包含於兩處。

請記住，`exp`、`nbf` 和 `iat` 是 **NumericDate**，請參閱相關[權杖到期 (exp 宣告)](#token-expiration-exp-claim)。


標頭可以透過 `options.header` 物件自訂。

除非指定 `noTimestamp`，否則產生的 jwts 將預設包含 `iat` (issued at) 宣告。 如果在承載中插入 `iat`，則會用它來計算其他事項 (例如在 `options.expiresIn` 中提供時間範圍的 `exp`)，而不會使用實際的時間戳記。

使用預設 (HMAC SHA256) 的同步簽署

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

使用 RSA SHA256 的同步簽署
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

非同步簽署
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

回溯 jwt 30 秒
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>權杖到期 (exp 宣告)

JWT 的標準定義到期的 `exp` 宣告。 到期是以 **NumericDate** 表示：

> JSON 數值表示從 1970-01-01T00:00:00Z UTC 到指定 UTC 日期/時間的秒數，忽略閏秒。  這相當於 IEEE 標準 1003.1，2013 年版 [POSIX.1] 定義「UNIX 時間」，其中每一天都確切計為 86400 秒，而不是可以表示的非整數值。  如需關於一般日期/時間和特定 UTC 的詳細資料，請參閱 RFC 3339 [RFC3339]。

這表示 `exp` 欄位應包含 UNIX 秒數。

簽署 1 小時到期時間的權杖：

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

使用此程式庫產生類似此權杖的另一種方式是：

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(非同步) 如果提供回呼，函式則會非同步作用。 如果簽章有效且選擇性到期、對象或簽發者有效，則可以連同已解碼的承載呼叫回呼。 如果沒有，將會以錯誤呼叫它。

(同步) 如果未提供回撥，函式則會同步作用。 如果簽章有效且選擇性到期、對象或簽發者有效，則會傳回已解碼的承載。 如果沒有，將會擲回錯誤。

`token` 是 JsonWebToken 字串。

`secretOrPublicKey` 是字串或緩衝區，其中包含 HMAC 演算法的秘密，或 RSA 和 ECDSA 的 PEM 編碼格式公開金鑰。
如果非同步呼叫 `jwt.verify`，`secretOrPublicKey` 可以是擷取秘密或公開金鑰的函式。 如需詳細範例，請參閱以下說明。

如[此註解](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138) (英文) 所述，則會有其他程式庫預期使用 base64 編碼秘密 (使用 base64 編碼的隨機位元組)。如果您也是如此，則可以傳遞 `Buffer.from(secret, 'base64')`。這樣做之後，將使用 base64 編碼秘密，且權杖驗證將使用原始的隨機位元組。

`options`

* `algorithms`：包含允許演算法名稱的字串清單。 例如 `["HS256", "HS384"]`。
* `audience`：如果您想要檢查對象 (`aud`)，請在此處提供一個值。 您可以根據字串、規則運算式或字串及/或規則運算式清單檢查對象。 
  > 例如：`"urn:foo"`、`/urn:f[o]{2}/`、`[/urn:f[o]{2}/, "urn:bar"]`
* `complete`：傳回已解碼 `{ payload, header, signature }` 的物件，而不是只有承載的通常內容。
* `issuer` (選擇性)：`iss` 欄位的有效值的字串或字串陣列。
* `ignoreExpiration`：如果為 `true`，則不會驗證權杖是否到期。
* `ignoreNotBefore`...
* `subject`：如果您想要檢查主體 (`sub`)，請在此處提供一個值。
* `clockTolerance`：檢查 `nbf` 和 `exp` 宣告時容許的秒數，以處理不同伺服器之間些微時鐘差異。
* `maxAge`：權杖仍有效的最長使用期限。 以秒或描述時間範圍 [zeit/毫秒](https://github.com/zeit/ms)的字串表示。 
  > 例如：`1000`、`"2 days"`、`"10h"` 和 `"7d"`。 數值會視為秒數來解譯。 如果使用字串，請務必提供時間單位 (天、小時等)，否則會預設使用毫秒作為單位 (例如將 `"120"` 視為 `"120ms"`)。
* `clockTimestamp`：應作為目前時間的時間 (單位為秒)，以用於進行所有所需的比較。
* `nonce`：如果您想要檢查 `nonce` 宣告，請在此處提供一個字串值。 它用於 ID 權杖的 Open ID。 ([Open ID 實作備註](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes)) (英文)


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(同步) 傳回已解碼承載，但不驗證簽章是否有效。

> __警告：__ 這 __不會__ 驗證簽章是否有效。 您 __不__ 應將此用於不受信任的訊息。 建議您改用 `jwt.verify`。

`token` 是 JsonWebToken 字串。

`options`:

* `json`：在承載上強制執行 JSON.parse，即使標頭不包含 `"typ":"JWT"`。
* `complete`：傳回包含已解碼承載和標頭的物件。

範例

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>錯誤和程式碼
驗證期間可能擲回的錯誤。
錯誤是驗證回呼的第一個引數。

### <a name="tokenexpirederror"></a>TokenExpiredError

如果權杖已過期，則擲回錯誤。

錯誤物件：

* 名稱：'TokenExpiredError' (權杖過期錯誤)
* 訊息：'jwt expired' (jwt 已過期)
* 到期日期：[ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
錯誤物件：

* 名稱：'JsonWebTokenError' (Json Web 權杖錯誤)
* message:
  * 'jwt malformed' (jwt 格式錯誤)
  * 'jwt signature is required' (需要 jwt 簽章)
  * 'invalid signature' (簽章無效)
  * 'jwt audience invalid. expected: [OPTIONS AUDIENCE]' (jwt 對象無效。必須是：[OPTIONS AUDIENCE])
  * 'jwt issuer invalid. expected: [OPTIONS ISSUER]' (jwt 簽發者無效。必須是：[OPTIONS ISSUER])
  * 'jwt id invalid. expected: [OPTIONS JWT ID]' (jwt ID 無效。必須是：[OPTIONS JWT ID])
  * 'jwt subject invalid. expected: [OPTIONS SUBJECT]' (jwt 主體無效。必須是：[OPTIONS SUBJECT])

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
如果目前時間在 nbf 宣告之前，則擲回此錯誤。

錯誤物件：

* 名稱：'NotBeforeError'
* 訊息：'jwt not active' (jwt 未啟用)
* 日期：2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>支援的演算法

支援的演算法陣列。 目前支援下列演算法。

alg 參數值 | 數位簽章或 MAC 演算法
----------------|----------------------------
HS256 | 使用 SHA-256 雜湊演算法的 HMAC
HS384 | 使用 SHA-384 雜湊演算法的 HMAC
HS512 | 使用 SHA-512 雜湊演算法的 HMAC
RS256 | 使用 SHA-256 雜湊演算法的 RSASSA-PKCS1-v1_5
RS384 | 使用 SHA-384 雜湊演算法的 RSASSA-PKCS1-v1_5
RS512 | 使用 SHA-512 雜湊演算法的 RSASSA-PKCS1-v1_5
PS256 | 使用 SHA-256 雜湊演算法的 RSASSA-PSS (僅限 node ^6.12.0 或 8.0.0 以上版本)
PS384 | 使用 SHA-384 雜湊演算法的 RSASSA-PSS (僅限 node ^6.12.0 或 8.0.0 以上版本)
PS512 | 使用 SHA-512 雜湊演算法的 RSASSA-PSS (僅限 node ^6.12.0 或 8.0.0 以上版本)
ES256 | 使用 P-256 曲線和 SHA-256 雜湊演算法的 ECDSA
ES384 | 使用 P-384 曲線和 SHA-384 雜湊演算法的 ECDSA
ES512 | 使用 P-521 曲線和 SHA-512 雜湊演算法的 ECDSA
無 | 未包含數位簽章或 MAC 值

## <a name="refreshing-jwts"></a>重新整理 JWT

首先我們建議您仔細思考，自動重新整理 JWT 是否不會在您的系統中引入任何弱點。

我們不太建議將此納入程式庫的一部分，但您可以查看[此範例](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48) (英文) 以如何完成此工作。
除了該範例以外，還有[一個問題](https://github.com/auth0/node-jsonwebtoken/issues/122)與[提取要求](https://github.com/auth0/node-jsonwebtoken/pull/172)可供查看，以協助您更深入了解此主題。

# <a name="todo"></a>TODO

* 未檢查 X.509 信任鏈結

## <a name="issue-reporting"></a> 問題報告 

如果您已發現錯誤或有功能要求，請在此存放庫問題區段報告錯誤或要求。 請不要在公開的 GitHub 問題追蹤器上報告安全性弱點。 此[責任披露計劃](https://auth0.com/whitehat) (英文) 詳述揭露安全性問題的程序。

## <a name="author"></a>作者

[Auth0](https://auth0.com)

## <a name="license"></a>授權

此專案透過 MIT 授權進行授權。 如需詳細資訊，請參閱 [LICENSE](LICENSE) 檔案。
