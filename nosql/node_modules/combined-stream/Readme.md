---
ms.openlocfilehash: 0e4384a6edea7b3a580ffa5b32236b7f8b251834
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050651"
---
# <a name="combined-stream"></a>combined-stream

會依序發出多個其他資料流的一個串流。

**特別注意：** 目前 `combined-stream` 僅適用於第 1 版的資料流 (streams1)。 我們仍正在努力將此程式庫切換至第 2 版的資料流 (streams2)。 歡迎您提供任何協助。 :)與此同時，您也可以探索其他支援 streams2 的程式庫，但其與 `combined-stream` 之間的相容性有可能尚不穩定。

- [combined-stream2](https://www.npmjs.com/package/combined-stream2):一個相容於 streams2 的可用替代方案，可取代 combined-stream 模組。

- [multistream](https://www.npmjs.com/package/multistream)：會依序發出多個其他資料流的一個串流。

## <a name="installation"></a>安裝

``` bash
npm install combined-stream
```

## <a name="usage"></a>使用方式

以下為一個簡單範例，示範如何使用 combined-stream 將兩個檔案合併為一個檔案：

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

雖然上述範例能順利運行，但會暫停所有來源資料流，直到需要它們為止。 如果不想要讓這種情況發生，您可以將 `pauseStreams` 設定為 `false`：

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create({pauseStreams: false});
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

然而，如果您尚未取得所有來源資料流，或不想立即配置資源 (如檔案描述項、記憶體等)，該怎麼辦？
在此情況下，您也可以藉由呼叫 `next()` 函式來提供資料流的回呼：

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(function(next) {
  next(fs.createReadStream('file1.txt'));
});
combinedStream.append(function(next) {
  next(fs.createReadStream('file2.txt'));
});

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

## <a name="api"></a>API

### <a name="combinedstreamcreateoptions"></a>CombinedStream.create([選項])

將傳回新的合併資料流物件。 可用選項包括：

* `maxDataSize`
* `pauseStreams`

這些選項的效果如下所述。

### <a name="combinedstreampausestreams--true"></a>combinedStream.pauseStreams = `true`

是否要將背壓套用至底層資料流。 如果設定為 `false`，則永遠不會暫停底層資料流。 如果設定為 `true`，底層資料流會在附加後立即暫停，或是 `delayedStream.pipe()` 想要節流時也會暫停。

### <a name="combinedstreammaxdatasize--2--1024--1024"></a>combinedStream.maxDataSize = `2 * 1024 * 1024`

要緩衝處理所有來源資料流的最大位元組數量 (或字元數)。
如果超過設定值，則 `combinedStream` 將發出 `'error'` 事件。

### <a name="combinedstreamdatasize--0"></a>combinedStream.dataSize = `0`

目前 `combinedStream` 緩衝處理的位元組數量 (或字元數)。

### <a name="combinedstreamappendstream"></a>combinedStream.append(stream)

將指定的 `stream` 附加至 combinedStream 物件。 如果 `pauseStreams` 設定為 true，此資料流也會立即暫停。

`streams` 也可以是呼叫單一參數 `next` 的函式。 而 `next` 也是一個函式，需經過叫用才能提供 `next` 資料流，請參閱上述範例。

不論 `stream` 的附加方式為何，combined-stream 一律會對此附加 `'error'` 接聽程式，因此您不需要手動附加接聽程式。

特殊情況：`stream` 也可以是字串或緩衝區。

### <a name="combinedstreamwritedata"></a>combinedStream.write(data)

建議不要呼叫此函式，`combinedStream` 已替您將附加資料流以管線輸入其中了。

### <a name="combinedstreamresume"></a>combinedStream.resume()

令 `combinedStream` 開始清空所管理的資料流。 此為冪等函式，每次都會發出 `'resume'` 事件至正在清空的資料流。

### <a name="combinedstreampause"></a>combinedStream.pause();

如果 `combinedStream.pauseStreams` 設定為 `false`，則不會執行任何動作。
否則，就會發出 `'pause'` 事件至目前正在清空的資料流，讓您得以套用背壓。

### <a name="combinedstreamend"></a>combinedStream.end();

將 `combinedStream.writable` 設定為 false，發出 `'end'` 事件，並從佇列中移除所有資料流。

### <a name="combinedstreamdestroy"></a>combinedStream.destroy();

功能與 `combinedStream.end()` 相同，不同之處在於它會發出 `'close'` 事件，而非 `'end'`。

## <a name="license"></a>授權

combined-stream 是根據 MIT 授權進行授權。
