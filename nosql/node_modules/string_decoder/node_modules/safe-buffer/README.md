---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050548"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![下載][downloads-image]][downloads-url] [![Javascript 樣式指南][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>更安全的 Node.js Buffer API

**請在所有 Node.js 版本中使用新的 Node.js Buffer API (`Buffer.from`、`Buffer.alloc`、`Buffer.allocUnsafe`、`Buffer.allocUnsafeSlow`)。**

**可用時請使用內建實作。**

## <a name="install"></a>安裝

```
npm install safe-buffer
```

## <a name="usage"></a>usage

此套件的目標是為 node.js `Buffer` 提供安全的取代項目。

這是 `Buffer` 的置放取代項目。 如需使用，請在您的 node.js 模組頂端加入一個 `require` 行：

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>類別方法：Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

使用一個八位元 `array` 配置新的 `Buffer`。

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

如果 `array` 並非 `Array`，會擲回 `TypeError`。

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>類別方法：Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} `TypedArray` 或 `new ArrayBuffer()` 的 `.buffer` 屬性
* `byteOffset` {Number} 預設值：`0`
* `length` {Number} 預設值：`arrayBuffer.length - byteOffset`

傳遞 `TypedArray` 執行個體的 `.buffer` 屬性參考時，新建立的 `Buffer` 配置記憶體會與 TypedArray 的配置記憶體相同。

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

選擇性 `byteOffset` 和 `length` 引數會在 `arrayBuffer` 內指定記憶體範圍，該範圍將由 `Buffer` 共用。

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

如果 `arrayBuffer` 並非 `ArrayBuffer`，會擲回 `TypeError`。

### <a name="class-method-bufferfrombuffer"></a>類別方法：Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

將傳遞的 `buffer` 資料複製到新的 `Buffer` 執行個體。

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

如果 `buffer` 並非 `Buffer`，會擲回 `TypeError`。

### <a name="class-method-bufferfromstr-encoding"></a>類別方法：Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} 要編碼的字串。
* `encoding` {String} 要使用的編碼，預設值：`'utf8'`

建立包含指定 JavaScript 字串 `str` 的新 `Buffer`。 若已提供，`encoding` 參數會識別字元編碼。
如未提供，則 `encoding` 預設為 `'utf8'`。

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

如果 `str` 不是字串，會擲回 `TypeError`。

### <a name="class-method-bufferallocsize-fill-encoding"></a>類別方法：Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} 預設值：`undefined`
* `encoding` {String} 預設值：`utf8`

配置一個新的 `size` 位元組的 `Buffer`。 如果 `fill` 為 `undefined`，則 `Buffer` 會 *以零填滿*。

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` 必須小於或等於 `require('buffer').kMaxLength` 的值 (在 64 位元架構上，`kMaxLength` 為 `(2^31)-1`)。 否則會擲回 [`RangeError`][]。 如指定小於或等於 0 的 `size`，會建立零長度的緩衝區。

如果指定了 `fill`，則呼叫 `buf.fill(fill)` 會將配置的 `Buffer` 初始化。 如需詳細資訊，請參閱 [`buf.fill()`][]。

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

如果同時指定了 `fill` 與 `encoding`，則呼叫 `buf.fill(fill, encoding)` 會將配置的 `Buffer` 初始化。 例如：

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

呼叫 `Buffer.alloc(size)` 可能會比替代 `Buffer.allocUnsafe(size)` 項目慢很多，但可確保新建立的 `Buffer` 執行個體內容 *永遠不會包含敏感性資料*。

如果 `size` 不是數字，會擲回 `TypeError`。

### <a name="class-method-bufferallocunsafesize"></a>類別方法：Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

配置新的 *非零填滿* 的 `Buffer` 位元組 `size`。  `size` 必須小於或等於 `require('buffer').kMaxLength` 的值 (在 64 位元架構上，`kMaxLength` 為 `(2^31)-1`)。 否則會擲回 [`RangeError`][]。 如指定小於或等於 0 的 `size`，會建立零長度的緩衝區。

以這種方式建立的 `Buffer` 執行個體，其基礎記憶體 *不會初始化*。 新建 `Buffer` 的內容不明，且 *可能包含敏感性資料*。 使用 [`buf.fill(0)`][] 可將這類 `Buffer` 執行個體初始化為零。

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

如果 `size` 不是數字，會擲回 `TypeError`。

請注意，`Buffer` 模組只會在 `size` 小於或等於 `Buffer.poolSize >> 1` (`Buffer.poolSize`的 floor 除以二) 的情況下，預先配置大小 `Buffer` 的內部 `Buffer.poolSize` 執行個體作為集區，以便使用 `Buffer.allocUnsafe(size)` 快速配置新的 `Buffer` 執行個體 (以及已取代的 `new Buffer(size)` 建構函式)。 `Buffer.poolSize` 的預設值為 `8192`，但可以修改。

使用預先配置的內部記憶體集區時，呼叫 `Buffer.alloc(size, fill)` 或 `Buffer.allocUnsafe(size).fill(fill)` 有很大的差異。具體來說，`Buffer.alloc(size, fill)` *永遠不會* 使用內部緩衝集區，而 `Buffer.allocUnsafe(size).fill(fill)` *會* 使用內部緩衝集區 (若 `size` 小於或等於 `Buffer.poolSize` 的一半)。 差異很細微，但當應用程式需要提供 `Buffer.allocUnsafe(size)` 所需的額外效能時，可能就相當重要了。

### <a name="class-method-bufferallocunsafeslowsize"></a>類別方法：Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

配置新的 *非零填滿* 和 `size` 位元組的非集區 `Buffer`。  `size` 必須小於或等於 `require('buffer').kMaxLength` 的值 (在 64 位元架構上，`kMaxLength` 為 `(2^31)-1`)。 否則會擲回 [`RangeError`][]。 如指定小於或等於 0 的 `size`，會建立零長度的緩衝區。

以這種方式建立的 `Buffer` 執行個體，其基礎記憶體 *不會初始化*。 新建 `Buffer` 的內容不明，且 *可能包含敏感性資料*。 使用 [`buf.fill(0)`][] 可將這類 `Buffer` 執行個體初始化為零。

使用 `Buffer.allocUnsafe()` 配置新的 `Buffer` 執行個體時，4KB 以下的配置會預設從單一預先配置的 `Buffer` 配量。 如此一來便能讓應用程式在建立許多個別配置的緩衝區時，避免造成記憶體回收額外負荷。 此方法可藉由消除追蹤和清除許多 `Persistent` 物件的需求，來改善效能和記憶體使用量。

不過，如果開發人員可能需要在不確定的時間內從集區保留少量記憶體，那麼可能適合使用 `Buffer.allocUnsafeSlow()` 建立非集區的緩衝區執行個體後，再複製相關位元。

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

只有當開發人員在應用程式中發現過多保留記憶體 *「之後」* ，才應該使用 `Buffer.allocUnsafeSlow()` 作為最後手段。

如果 `size` 不是數字，會擲回 `TypeError`。

### <a name="all-the-rest"></a>所有其餘部分

其餘 `Buffer` API 都與 node.js 完全相同。
[參閱相關文件](https://nodejs.org/api/buffer.html)。


## <a name="related-links"></a>相關連結

- [Node.js 問題：Buffer(number) 並不安全](https://github.com/nodejs/node/issues/4660)
- [Node.js 加強程式提案：Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>為什麼 `Buffer` 不安全？

目前 node.js `Buffer` 建構函式會多載處理許多不同的引數類型，例如 `String`、`Array`、`Object`、`TypedArrayView` (`Uint8Array` 等等)、`ArrayBuffer` 以及 `Number`。

API 已針對方便使用進行最佳化：您可以擲回任何類型，API 會嘗試執行您想要的動作。

因為緩衝區建構函式非常強大，所以您通常會看到類似以下的程式碼：

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***但是，如果使用 `Number` 引數呼叫 `toHex`，會發生什麼事？***

### <a name="remote-memory-disclosure"></a>遠端記憶體洩漏

如果攻擊者能讓您的程式使用 `Number` 引數來呼叫 `Buffer` 建構函式，就能藉此透過 node.js 流程配置未初始化記憶體。
這可能會揭露 TLS 私密金鑰、使用者資料或資料庫密碼。

當 `Buffer` 建構函式傳遞 `Number` 引數時，會傳回指定 `size` 記憶體的 **未初始化** 區塊。 當您建立類似這樣的 `Buffer` 時，您 **必須** 先覆寫內容，再將內容傳回給使用者。

來自 [node.js 文件](https://nodejs.org/api/buffer.html#buffer_new_buffer_size) (英文)：

> `new Buffer(size)`
>
> - `size` 數字
>
> 以這種方式建立的 `Buffer` 執行個體，其基礎記憶體不會初始化。
> **新建的 `Buffer` 內容不明，且可能包含敏感性資料。** 使用 `buf.fill(0)` 將緩衝區初始化為零。

(強調我們自己的。)

每當程式設計人員想要建立未初始化的 `Buffer` 時，您通常會看到如下的程式碼：

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>這是否可能會在實際程式碼中發生問題？

可以。 在 JavaScript 這類動態型別語言中，忘記檢查變數類型的情況出乎意料地常見。

若採用錯誤的類型，通常會導致程式因未發現的例外狀況而損毀， 但因忘記檢查 `Buffer` 建構函式引數類型而導致的失敗模式，問題又會更加嚴重。

以下是採用 JSON 承載並將其轉換成十六進位的易受攻擊服務範例：

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

在此範例中，HTTP 用戶端只需要傳送：

```json
{
  "str": 1000
}
```

伺服器便會傳回 1,000 個位元組的未初始化記憶體。

這是非常嚴重的錯誤。 嚴重程度近似於允許遠端攻擊者揭露 OpenSSL 流程記憶體的 [Heartbleed 錯誤](http://heartbleed.com/)。


### <a name="which-real-world-packages-were-vulnerable"></a>哪些實際套件容易受到攻擊？

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) 和我 ([Feross Aboukhadijeh](http://feross.org/)) 在我們的其中一個套件 [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht) 中發現這個問題。 此錯誤可讓網際網路上的任何人將一系列訊息傳送給 `bittorrent-dht` 的使用者，並一次顯示 node.js 流程中 20 個位元組的未初始化記憶體。

請在此查看用於修正這個錯誤的[認可](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8) (英文)。 我們發行了新的修正版本，並建立了 [Node 安全性專案揭露](https://nodesecurity.io/advisories/68)，並在 npm 上取代了所有易受攻擊的版本，如此一來使用者就會收到請他們升級至較新版本的警告。

#### [`ws`](https://www.npmjs.com/package/ws)

這讓我們開始思考是否還有其他易受攻擊的套件。 結果，短時間內我們果然在最普及的 node.js WebSocket 實作 [`ws`](https://www.npmjs.com/package/ws) (英文) 中發現相同的問題。

如果用 `Number` 參數 (而非預期的 `String` 或 `Buffer`) 呼叫特定 API，則未初始化的伺服器記憶體會揭露給遠端的同儕節點。

這些是易受攻擊的方法：

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

以下是具有特定回應功能的易受攻擊通訊端伺服器：

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

如在伺服器上呼叫 `socket.send(number)`，將會揭露伺服器記憶體。

[這個版本](https://github.com/websockets/ws/releases/tag/1.0.1) (英文) 已修正這個問題，並附上更詳細的說明。 在此，我們要對快速進行修正的 [Arnout Kazemier](https://github.com/3rd-Eden) 致上敬意。 這是 [Node 安全性專案揭露 ](https://nodesecurity.io/advisories/67)。


### <a name="whats-the-solution"></a>解決方案為何？

node.js 提供了快速的方式來取得記憶體，這點確實很重要，否則效能關鍵應用程式會無謂地變慢很多。

但程式設計人員也需要有更好的方式 *表明我們的意圖*， **如想要未初始化的記憶體，必須明確提出要求才能取得。**

敏感性功能不應封裝至為方便開發人員使用，而寬鬆地接受多種類型的 API 中， 這類型 API 會助長未仔細檢查類型便傳遞變數的懈怠做法。

#### <a name="a-new-api-bufferallocunsafenumber"></a>新的 API：`Buffer.allocUnsafe(number)`

使用未初始化記憶體建立緩衝區的功能，應該由另一個 API 提供。 我們建議使用 `Buffer.allocUnsafe(number)`。 如此一來，經常收到各種不同類型使用者輸入的 API，就不會具備這項功能。

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>如何修正 node.js 核心？

我們已將 [PR 傳送至 node.js 核心](https://github.com/nodejs/node/pull/4514) (英文) (合併為 `semver-major`)，用於防禦以下案例：

```js
var str = 16
new Buffer(str, 'utf8')
```

在這個案例中，程式設計人員意圖將第一個引數設為字串，因為他們將編碼傳遞為第二個引數。 目前在 `new Buffer(number, encoding)` 的案例中，node.js 會配置未初始化的記憶體，但這可能不符合程式設計人員的預期。

不過這個方法也無法完全解決問題，因為如果程式設計人員在沒有 `encoding` 參數的情況下執行 `new Buffer(variable)`，便無從得知他們的意圖。 如果 `variable` 可以為數字，就會傳回未初始化的記憶體。

### <a name="whats-the-real-long-term-fix"></a>實際可行的長期修正方法為何？

需要未初始化的記憶體時，可以取代和移除 `new Buffer(number)`，改用 `Buffer.allocUnsafe(number)`。 但這麼做會導致上千個套件中斷。

~~我們認為最佳解決方案是：~~

~~1.變更 `new Buffer(number)` 以傳回安全、清除乾淨的記憶體~~

~~2.建立新 API 以建立未初始化緩衝區。我們提議使用：`Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>更新

我們現在支援新增三個新的 API：

- `Buffer.from(value)` - 從任何類型轉換成緩衝區
- `Buffer.alloc(size)` - 建立零填滿緩衝區
- `Buffer.allocUnsafe(size)` - 建立指定大小的未初始化緩衝區

這可解決影響 `ws` 和 `bittorrent-dht` 的核心問題，亦即在運用 `Buffer(variable)` 時受騙使用數字引數的問題。

如此一來，現有的程式碼會繼續運作，對 npm 生態系統的影響會降到最低。 經過一段時間後，npm 維護人員可以移轉效能關鍵程式碼，使用 `Buffer.allocUnsafe(number)` 取代 `new Buffer(number)`。


### <a name="conclusion"></a>結論

我們認為目前的 `Buffer` API 有嚴重的設計問題： 在符合「開發人員人體工學」且便於使用的 API 中置入高風險功能，會助長不安全軟體的傳播。

這不僅僅是理論之辯，因為我們已經在部分相當普及的 npm 套件中發現這個問題。

幸運的是，目前可立即套用一個簡單的修正方法來處理： 使用 `safe-buffer` 取代 `buffer`。

```js
var Buffer = require('safe-buffer').Buffer
```

最後，我們希望 node.js 核心可以切換到這個更安全的新行為。 由於這並不是中斷性變更，因此對生態系統造成的影響會很小。
受到良好維護的普及套件很快就可進行更新，改為使用 `Buffer.alloc`，而比較舊又不安全的套件也能不可思議地變安全，免於遭受攻擊媒介的危害。


## <a name="links"></a>連結

- [Node.js PR: buffer：如果傳遞長度和 enc，則擲回](https://github.com/nodejs/node/pull/4514) (英文)
- [Node 安全性專案揭露：`ws`](https://nodesecurity.io/advisories/67)
- [Node 安全性專案揭露：`bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>貢獻

發現 `bittorrent-dht` ([揭露內容](https://nodesecurity.io/advisories/68)) 和 `ws`([揭露內容](https://nodesecurity.io/advisories/67)) 中的原始問題的是 [Mathias Buus](https://github.com/mafintosh) 和 [Feross Aboukhadijeh](http://feross.org/)。

感謝 [Adam Baldwin](https://github.com/evilpacket) 協助揭露這些問題以及執行 [Node 安全性專案](https://nodesecurity.io/)。

感謝 [John Hiesey](https://github.com/jhiesey) 協助校訂此「讀我檔案」以及稽核程式碼。


## <a name="license"></a>授權

MIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)
