---
ms.openlocfilehash: ca1f677bd38876befee833fcedd10388a71aecf4
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053027"
---
<a name="agent-base"></a>agent-base
==========
### <a name="turn-a-function-into-an-httpagenthttpagent-instance"></a>將函式轉換成 [`http.Agent`][http.Agent] 執行個體
[![組建狀態](https://github.com/TooTallNate/node-agent-base/workflows/Node%20CI/badge.svg)](https://github.com/TooTallNate/node-agent-base/actions?workflow=Node+CI)

此模組提供 `http.Agent` 產生器。 您向此模組傳遞非同步回呼函式後，模組會傳回新的 `http.Agent` 執行個體，而該執行個體會在傳送連出 HTTP 要求時，叫用指定的回呼函式。

#### <a name="some-subclasses"></a>部分子類別：

以下是一些更有趣的 `agent-base` 用法。
您可以傳送提取要求並列出您的用法！

 * [`http-proxy-agent`][http-proxy-agent]：HTTP 端點的 HTTP(s) Proxy `http.Agent` 實作
 * [`https-proxy-agent`][https-proxy-agent]：HTTPS 端點的 HTTP(s) Proxy `http.Agent` 實作
 * [`pac-proxy-agent`][pac-proxy-agent]：HTTP 與 HTTPS 的 PAC 檔案 Proxy `http.Agent` 實作
 * [`socks-proxy-agent`][socks-proxy-agent]：HTTP 與 HTTPS 的 SOCKS Proxy `http.Agent` 實作


<a name="installation"></a>安裝
------------

使用 `npm` 安裝：

``` bash
$ npm install agent-base
```


<a name="example"></a>範例
-------

以下是針對每個 HTTP 要求建立伺服器的新 `net.Socket` 連線的最小範例 (等同於 `agent: false` 選項)：

```js
var net = require('net');
var tls = require('tls');
var url = require('url');
var http = require('http');
var agent = require('agent-base');

var endpoint = 'http://nodejs.org/api/';
var parsed = url.parse(endpoint);

// This is the important part!
parsed.agent = agent(function (req, opts) {
  var socket;
  // `secureEndpoint` is true when using the https module
  if (opts.secureEndpoint) {
    socket = tls.connect(opts);
  } else {
    socket = net.connect(opts);
  }
  return socket;
});

// Everything else works just like normal...
http.get(parsed, function (res) {
  console.log('"response" event!', res.headers);
  res.pipe(process.stdout);
});
```

也支援傳回 Promise 或使用 `async` 函式：

```js
agent(async function (req, opts) {
  await sleep(1000);
  // etc…
});
```

傳回另一個 `http.Agent` 執行個體，將該 HTTP 要求的責任「傳遞」給該代理程式：

```js
agent(function (req, opts) {
  return opts.secureEndpoint ? https.globalAgent : http.globalAgent;
});
```


<a name="api"></a>API
---

## <a name="agentfunction-callback-object-options--httpagent"></a>Agent(Function callback[, Object options]) → [http.Agent][]

建立基底 `http.Agent`，會為每個將其當作 `agent` 使用的 HTTP 要求，執行回呼函式 `callback`。 這個回呼函式負責建立在 HTTP 要求中當作基礎通訊端的 `stream.Duplex` 執行個體。

`options` 物件接受下列屬性：

  * `timeout` - 數字 - `callback()` 函式的逾時值 (以毫秒為單位)， 預設為無限 (選用)。

回呼函式須具備以下簽章：

### <a name="callbackhttpclientrequest-req-object-options-function-cb--undefined"></a>callback(http.ClientRequest req, Object options, Function cb) → undefined

透過存取 ClientRequest `req` 可讀取要求標頭、路徑等。`options` 物件包含傳遞給 `http.request()`/`https.request()` 函式呼叫的選項，且已經過格式化，可直接傳遞給 `net.connect()`/`tls.connect()` 或任何您想用於建立通訊端的方法。 將建立好的通訊端傳遞給回呼函式 `cb`；建立後，HTTP 要求會繼續執行。

如將 `https` 模組用於叫用 HTTP 要求，則 `options` 的 `secureEndpoint` 屬性 _會設為 `true`_ 。


<a name="license"></a>授權
-------

(MIT 授權)

Copyright (c) 2013 Nathan Rajlich &lt;nathan@tootallnate.net&gt;

在此免費授與權限給任何取得本軟體副本與相關文件檔案 (以下簡稱「軟體」) 的人員，以供其在不受限制的情況下處理軟體，包括但不限於使用、複製、修改、合併、發佈、散布、再授權及/或銷售軟體副本的權利，以及允許作為軟體提供對象的人員這麼做，但須遵守下列條件：

上述著作權聲明和此權限聲明應包含在「軟體」的所有複本或重要部分中。

軟體係依「現況」提供，不附帶任何形式的明示或默示擔保，包括但不限於商品的適售性或某特定目的之合適性及未侵權。
作者或著作權持有者對於任何索賠、損害或其他責任，均不負任何責任，不論是起因於、出自或連結至軟體或軟體的使用或其他交易所造成的訴訟或合約、侵權或其他事由。

[http-proxy-agent]: https://github.com/TooTallNate/node-http-proxy-agent
[https-proxy-agent]: https://github.com/TooTallNate/node-https-proxy-agent
[pac-proxy-agent]: https://github.com/TooTallNate/node-pac-proxy-agent
[socks-proxy-agent]: https://github.com/TooTallNate/node-socks-proxy-agent
[http.Agent]: https://nodejs.org/api/http.html#http_class_http_agent
