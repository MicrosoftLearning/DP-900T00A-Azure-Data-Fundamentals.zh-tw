---
ms.openlocfilehash: 21db9b7ec97b7028a031a18867aab00575b09850
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138053019"
---
# <a name="delayed-stream"></a>delayed-stream

緩衝來自資料流的事件，直到您準備開始處理為止。

## <a name="installation"></a>安裝

``` bash
npm install delayed-stream
```

## <a name="usage"></a>使用方式

以下範例示範如何撰寫將回應速度延遲 1000 毫秒的 HTTP 回應伺服器。

``` javascript
var DelayedStream = require('delayed-stream');
var http = require('http');

http.createServer(function(req, res) {
  var delayed = DelayedStream.create(req);

  setTimeout(function() {
    res.writeHead(200);
    delayed.pipe(res);
  }, 1000);
});
```

假如您並未使用 `Stream#pipe`，也可以透過呼叫 `delayedStream.resume()` 手動釋放緩衝事件：

``` javascript
var delayed = DelayedStream.create(req);

setTimeout(function() {
  // Emit all buffered events and resume underlaying source
  delayed.resume();
}, 1000);
```

## <a name="implementation"></a>實作

您必須了解一些與這項實作相關的資訊，才能正確使用此中繼資料流。

### <a name="event-buffering--proxying"></a>事件緩衝處理/通過 Proxy 處理事件

覆寫 `source.emit` 方法即可攔截 `source` 資料流的所有事件。 在節點實作全部擷取事件接聽程式之前，這是唯一的方法。

不過，無論您是否已釋放延遲資料流，該資料流依然會繼續發出所有從 `source` 擷取的事件。

延遲資料流在建立之後便會開始擷取所有 `source` 事件，並儲存在內部事件緩衝區。 只要呼叫 `delayedStream.release()`，所有緩衝事件就會發出至 `delayedStream`，事件緩衝區則會清空， 之後延遲資料流的唯一用途就是成為底層來源的 Proxy。

### <a name="error-handling"></a>錯誤處理

與其他任何事件一樣，`source` 的錯誤事件會進行緩衝處理/以 Proxy 處理，
不過 `delayedStream.create` 會將一個不作業 `'error'` 接聽程式連結至 `source`， 如此一來您便無須管理兩個位置，只要處理 `delayedStream` 物件上的錯誤即可。

### <a name="buffer-limits"></a>緩衝限制

延遲資料流提供 `maxDataSize` 屬性，可用於限制受到緩衝的資料量。 為免您受到不會回應 `source.pause()` 的不良 `source` 資料流影響，這項功能會預設為啟用。

## <a name="api"></a>API

### <a name="delayedstreamcreatesource-options"></a>DelayedStream.create(source, [options])

傳回新的 `delayedStream`。 可用選項包括：

* `pauseStream`
* `maxDataSize`

這些屬性的說明列於下方。

### <a name="delayedstreamsource"></a>delayedStream.source

由此物件管理的 `source` 資料流。 當您將 `delayedStream` 四處傳遞，但仍然想要存取 `source` 物件的屬性時，這就能派上用場。

### <a name="delayedstreampausestream--true"></a>delayedStream.pauseStream = true

是否要在呼叫 `DelayedStream.create()` 時暫停底層 `source`。 之後修改這個屬性不會有任何作用。

### <a name="delayedstreammaxdatasize--1024--1024"></a>delayedStream.maxDataSize = 1024 * 1024

發出 `error` 之前要緩衝處理的資料量。

如果底層來源發出的是 `Buffer` 物件，那麼 `maxDataSize` 指的是位元組。

如果底層來源發出的是 JavaScript 字串，則大小指的是字元。

如果您很了解這項操作，可以將這個屬性設為 `Infinity` 以停用這項功能， 也可以在執行階段修改這個屬性。

### <a name="delayedstreamdatasize--0"></a>delayedStream.dataSize = 0

到目前為止緩衝處理的資料量。

### <a name="delayedstreamreadable"></a>delayedStream.readable

傳回 `source.readable` 值的 ECMA5 getter。

### <a name="delayedstreamresume"></a>delayedStream.resume()

如果 `delayedStream` 尚未釋放，則呼叫 `delayedStream.release()`，

無論在哪種情況下，都會呼叫 `source.resume()`。

### <a name="delayedstreampause"></a>delayedStream.pause()

呼叫 `source.pause()`。

### <a name="delayedstreampipedest"></a>delayedStream.pipe(dest)

呼叫 `delayedStream.resume()` 然後透過 Proxy 將引數傳遞至 `source.pipe`。

### <a name="delayedstreamrelease"></a>delayedStream.release()

發出並清除目前為止緩衝處理的所有事件。 這並不會使底層來源恢復；如想恢復底層來源，請使用 `delayedStream.resume()`。

## <a name="license"></a>授權

delayed-stream 已獲得 MIT 授權。
