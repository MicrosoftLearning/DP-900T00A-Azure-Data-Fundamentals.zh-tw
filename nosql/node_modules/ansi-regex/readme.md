---
ms.openlocfilehash: 79b8bd5d8af7fd6d79dcb7c24b3f2e03e1d2a029
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050792"
---
# <a name="ansi-regex-build-statushttpstravis-ciorgchalkansi-regex"></a>ansi-RegEx [![組建狀態](https://travis-ci.org/chalk/ansi-regex.svg?branch=master)](https://travis-ci.org/chalk/ansi-regex)

> 符合 [ANSI 逸出程式碼](http://en.wikipedia.org/wiki/ANSI_escape_code)的規則運算式


## <a name="install"></a>安裝

```
$ npm install --save ansi-regex
```


## <a name="usage"></a>使用方式

```js
const ansiRegex = require('ansi-regex');

ansiRegex().test('\u001b[4mcake\u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001b[4mcake\u001b[0m'.match(ansiRegex());
//=> ['\u001b[4m', '\u001b[0m']
```

## <a name="faq"></a>常見問題集

### <a name="why-do-you-test-for-codes-not-in-the-ecma-48-standard"></a>為何要測試不符合 ECMA 48 標準的程式碼？

我們測試時執行的某些程式碼，是在尋找各種非標準或製造商專用程式碼清單時得到的。 如果我記得沒錯的話，我們會針對標準和非標準程式碼進行測試，因為大部分程式碼都遵循相同或類似的格式，而且可以在字串中安全地比對，不會有實際字串內容遭移除的風險。 有些非標準控制碼不遵循傳統格式 (例如以數字結尾的程式碼)，由於我們無法可靠地進行比對，因此就得將它們從測試中排除。

追溯其歷史，這些 ECMA 標準是在 90 年代初期制定，而 VT100 則是在 70 年代中/晚期設計。 那時候，控制碼仍沒有具體規範，工程師會在許多情況下加以使用，例如啟用可能已專屬化的硬體連接埠。 您可能會在處理器的 x86 結構中看到類似「無政府狀態」的程式碼；某些品牌的處理器上有許多代表不同涵義的「插斷」，但大部分都已淘汰。


## <a name="license"></a>授權

MIT © [Sindre Sorhus](http://sindresorhus.com)
