---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050591"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI — pure-JavaScript BigInts [![組建狀態](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) [![npm 上的 jsbi](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI 是 [ECMAScript BigInt 提案](https://tc39.es/proposal-bigint/) 的純 JavaScript 實作，已正式成為 ES2020 中 JavaScript 語言的一部分。

## <a name="installation"></a>安裝

```sh
npm install jsbi --save
```

## <a name="usage"></a>使用方式

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

請注意：在 `console.log()` `JSBI`執行個體時明確呼叫 `toString`，以查看其數值標記法 (例如 `String(max)` 或 `max.toString()`)。 如果沒有明確呼叫它 (例如 `console.log(max)`)，您會改為看到代表值的物件。

使用 [babel-plugin-transform-jsbi-to-Bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) (英文) 將 JSBI 程式碼轉譯成原生 BigInt 程式碼。

如需詳細資訊，請參閱下面的詳細指示。

## <a name="why"></a>為什麼？

在新型瀏覽器中，[原生 BigInt 已寄送](https://v8.dev/features/bigint) (在撰寫本文時，Google Chrome 67+、Opera 54+、Firefox 68+) 和 Node.js (v10.4+)，而且未來預期它們會發展到其他瀏覽器，這表示如果您想要讓程式碼在任何地方執行，您仍無法使用它們。

若要立即在程式碼中使用 BigInts，您需要程式庫。 但有一個困難點：BigInt 提案會變更運算子的行為 (例如 `+`、`>=` 等) 以便於在 BigInts 進行處理。 這些變更無法直接 polyfill；而且它們也會使它變得無法使用 (在大部分情況下)，反而使用 Babel 或類似工具將 BigInt 程式碼轉譯為後援程式碼。 原因是這類轉譯必須以對某些函式執行輸入類型檢查的呼叫，來取代程式中的每個單一運算子，這會造成無法接受的效能損失。

解決方案是以另一種方式四捨五入的方式執行：使用程式庫的語法撰寫程式碼，並在可用時 [將其轉譯為原生 BigInt 程式碼](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) (英文)。 JSBI 是專為此目的而設計的：它能提供 BigInt「polyfill」實作，其行為與即將推出的原生 BigInt 完全相同，但具有目前可在所有瀏覽器上寄送的語法。

其優於其他現有的大整數程式庫：

- 其運作方式與原生 BigInts 在可用時完全相同，因此若要移轉至它們，您可以 [以機械方式](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) (英文) 更新程式碼的語法；不需重新思考其邏輯。
- 著重於效能。 平均而言，JSBI 與 Google Chrome 目前寄送的原生實作具有效能競爭力。

## <a name="how"></a>怎麼做？

除了語法的機械差異之外，您可以使用 JSBI-BigInts，就 [像使用原生 BigInts 一樣](https://developers.google.com/web/updates/2018/05/bigint) (英文)。 在您以 `JSBI.BigInt` 取代 `BigInt` 之後，某些項目甚至看起來都相同：

| 作業            | native BigInts          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| 從字串建立 | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| 從數字建立 | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| 轉換成字串 | `a.toString(radix)`     | `a.toString(radix)`      |
| 轉換成數字 | `Number(a)`             | `JSBI.toNumber(a)`       |
| 截斷           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| 類型檢查           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

大部分運算子都會由方法呼叫取代：

| 作業                   | native BigInts | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| 加法                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| 減                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| 乘法              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| 除法                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| 餘數                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| 乘冪              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| 否定                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| 位元否定            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| 左移               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| 右移              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| 位元 [AND]               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| 位元 [OR]                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| 位元 [XOR]               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| 與其他 BigInts 的比較 | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

上述函式只能在 BigInts 上運作。 (它們不會在目前的實作中執行類型檢查，因為在我們假設您知道您執行的動作的情況下，執行這類檢查是在浪費時間。 請勿嘗試使用其他輸入來呼叫它們，否則您會嘗到一次「有趣的」失敗！)

當您提供混合類型的輸入時，某些作業特別有趣，例如將 BigInt 與數值做比較，或串連字串與 BigInt。 它們會實作為以個別原生運算子命名的靜態函式：

| 作業                       | native BigInts | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| 抽象相等比較    | `x == y`       | `JSBI.EQ(x, y)`  |
| 泛型 [不相等]             | `x != y`       | `JSBI.NE(x, y)`  |
| 泛型 [小於]             | `x < y`        | `JSBI.LT(x, y)`  |
| 泛型 [小於或等於]    | `x <= y`       | `JSBI.LE(x, y)`  |
| 泛型 [大於]          | `x > y`        | `JSBI.GT(x, y)`  |
| 泛型 [大於或等於] | `x >= y`       | `JSBI.GE(x, y)`  |
| 泛型加法                | `x + y`        | `JSBI.ADD(x, y)` |

此處的變數名稱和 `x` 和 `y` 指出，變數可以參考任何項目，例如：`JSBI.GT(101.5, BigInt('100'))` 或 `str = JSBI.ADD('result: ', BigInt('0x2A'))`。

可惜的是，還有一些完全不支援的項目：

| 不支援的作業 | native BigInts | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| 常值              | `a = 123n;`    | 不適用 ☹                                |
| increment             | `a++`          | 不適用 ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| 遞減             | `a--`          | 不適用 ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

不可能使用靜態函式來複寫完全符合原生 `++` 和 `--` 運算子的行為。 由於 JSBI 最終會轉譯，因此不會提供類似但不同的替代方案。 您可以改用 `JSBI.add()` 和 `JSBI.subtract()`。

## <a name="when"></a>何時？

現在！ JSBI 程式庫已準備好立即使用。

一旦任何地方都能原生支援 BigInts 時，請一次性使用 [babel-plugin-transform-jsbi-to-Bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) (英文) 將您的 JSBI 程式碼轉譯成原生 BigInt 程式碼。

檢視 [問題追蹤器](https://github.com/GoogleChromeLabs/jsbi/issues) (英文) 以深入瞭解 JSBI 的未來計畫，並邀請您加入討論！

較模糊版本的未來計畫是使用 JSBI 程式庫 (或其擴充功能) 作為其他 BigInt 相關功能的暫存位置。 官方提案刻意稍微少一點，並保留進一步的「程式庫功能」供後續提案使用。 範例包括合併 `exp`+`mod` 函式和位元操作函式。

## <a name="development"></a>部署

1. 複製此存放庫，並將 `cd` 複製到本機目錄。

1. 使用 `.nvmrc` 中指定的 Node.js 版本：

     ```sh
     nvm use
     ```

1. 安裝開發相依性：

    ```sh
    npm install
    ```

1. 執行測試：

    ```sh
    npm test
    ```

    如要查看命令的完整清單，請參閱 `npm run`。

## <a name="for-maintainers"></a>針對維護人員

### <a name="how-to-publish-a-new-release"></a>如何發佈新版本

1. 在 `main` 分支上將 `package.json` 中的版本號碼調高：

    ```sh
    npm version patch -m 'Release v%s'
    ```

    請 [視需要](https://semver.org/) (英文) 使用 `minor` 或 `major`，請不要使用 `patch`。

    請注意，這會產生 Git 認可 + 標記。

1. 推送發行認可和標記：

    ```sh
    git push
    ```

    接著，我們的 CI 會自動將新版本發佈至 npm。
