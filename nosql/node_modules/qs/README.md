---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050860"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![ 版本徽章][2]][1]</sup>

[![組建狀態][3]][4]
[![相依性狀態][5]][6]
[![開發人員相依性狀態][7]][8]
[![授權][license-image]][license-url]
[![下載][downloads-image]][downloads-url]

[![npm 徽章][11]][1]

具有新增安全性的查詢字串剖析和字串化程式庫。

主要維護人員：[Jordan Harband](https://github.com/ljharb)

**qs** 模組最初是由 [TJ Holowaychuk](https://github.com/visionmedia/node-querystring) 所建立與維護。

## <a name="usage"></a>使用方式

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>剖析物件

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

**qs** 可讓您在查詢字串內建立巢狀物件，方法是使用方括弧括住子索引鍵的名稱　`[]`。
例如，字串 `'foo[bar]=baz'` 會轉換成：

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

使用 `plainObjects` 選項時，經過剖析的值會以透過 `Object.create(null)` 建立的 Null 物件形式傳回，因此原型方法不會存在於該物件上，而使用者可依喜好將那些名稱設定為任何值：

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

根據預設，系統會忽略覆寫物件原型屬性的參數，如果您希望保留那些欄位的資料，可使用上述的 `plainObjects`，或將 `allowPrototypes` 設定為 `true`，讓使用者輸入以覆寫那些屬性。 *警告* 一般不建議您啟用此選項，因為它在嘗試使用已被覆寫的屬性時，可能會導致問題。 請謹慎使用此選項。

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

URI 編碼字串也適用：

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

您也可以對物件進行巢狀化，例如 `'foo[bar][baz]=foobarbaz'`：

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

根據預設，對物件進行巢狀化時，**qs** 只會剖析最多 5 個子系。 這表示如果您嘗試剖析類似 `'a[b][c][d][e][f][g][h][i]=j'` 的字串，所產生物件將會是：

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

將 `depth` 選項傳遞至 `qs.parse(string, [options])`，即可覆寫此深度：

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

使用 **qs** 來剖析使用者輸入時，深度限制有助於避免濫用情況，我們建議您將它設定為相對小的數字。

基於類似原因，**qs** 預設只會剖析最多 1000 個參數。 傳遞 `parameterLimit` 選項，即可覆寫此深度：

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

若要略過前置問號，請使用 `ignoreQueryPrefix`：

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

也可傳遞選擇性分隔符號：

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

分隔符號也可作為規則運算式：

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

選項 `allowDots` 可用於啟用點標記法：

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

如果您只能使用舊版的瀏覽器或服務，系統也支援將百分比編碼八位元解碼為 iso-8859-1：

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

有些服務會將初始 `utf8=✓` 值新增至表單，讓舊版的 Internet Explorer 更有可能以 utf-8 提交表單。 此外，伺服器可比對核取記號字元的錯誤編碼來檢查值，並偵測 *未* 以 utf-8 傳送的查詢字串或 `application/x-www-form-urlencoded` 本文，例如： 如果表單具有 `accept-charset` 參數，或包含的頁面具有不同的字元集。

**qs** 透過 `charsetSentinel` 選項支援這項機制。
如果受指定，傳回的物件將省略 `utf8` 參數。 根據核取記號的編碼方式而定，會使用此參數來切換至 `iso-8859-1`/`utf-8` 模式。

**重要**：若您同時指定 `charset` 選項和 `charsetSentinel` 選項，那麼當要求中包含可從中推斷實際字元集的 `utf8` 參數時，`charset` 將會被覆寫。 如此一來，`charset` 的運作方式會比照預設字元集，而不是權威字元集。

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

如果您想將語法 `&#...;` 解碼為實際字元，也可以指定 `interpretNumericEntities` 選項：

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

在 `charsetSentinel` 模式中偵測到字元集時，它也能運作。

### <a name="parsing-arrays"></a>剖析陣列

**qs** 也可使用類似的 `[]` 標記法來剖析陣列：

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

您也可以指定索引：

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

請注意，陣列中的索引與物件中的索引鍵的唯一差異，在於括弧之間的值必須是數字，才能建立陣列。 使用特定索引建立陣列時，**qs** 會壓縮疏鬆陣列，而只有現有值維持原本的排序：

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

您也可以使用 `allowSparse` 選項來剖析疏鬆陣列：

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

請注意，空字串也是值，而且會保留：

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

**qs** 也會將陣列中指定索引限制為 `20` 的最大索引。 任何索引大於 `20` 的陣列成員都會轉換成以索引作為索引鍵的物件。 例如，當有人傳送 `a[999999999]` 時，您便需要執行此動作來處理案例，而逐一查看這個龐大的陣列會耗費大量時間。

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

您可以傳遞 `arrayLimit` 選項來覆寫此限制：

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

若要完全停用陣列剖析，請將 `parseArrays` 設定為 `false`。

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

如果您混合標記法，**qs** 會將這兩個項目合併到物件中：

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

您也可建立物件陣列：

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

有些人使用逗號來聯結陣列，而 **qs** 能夠加以剖析：
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
(_這無法轉換巢狀物件，例如 `a={b:1},{c:d}`_ )

### <a name="stringifying"></a>字串化

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

進行字串化時，**qs** 預設會執行 URI 編碼輸出。 物件會如您所預期地進行字串化：

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

將 `encode` 選項設定為 `false` ，即可停用此編碼：

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

將 `encodeValuesOnly` 選項設定為 `true`，即可停用索引鍵編碼：
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

此編碼也可取代為設定為 `encoder` 選項的自訂編碼方法：

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

_(注意：如果 `encode` 為 `false`，則 `encoder` 選項不適用)_

與 `encoder` 類似的是，`decoder` 選項可供 `parse` 覆寫屬性和值的解碼：

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

您可透過提供給編碼器的類型引數，使用不同的邏輯來編碼索引鍵和值：

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

類型引數也會提供給解碼器：

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

為了清晰起見，超過這個點的範例會顯示為輸出並未進行 URI 編碼。 請注意，在這種情況下，傳回的值 *會* 在實際使用方式中進行 URI 編碼。

當陣列經過字串化時，預設會產生明確的索引：

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

您可將 `indices` 選項設定為 `false` 來進行覆寫：

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

您可使用 `arrayFormat` 選項來指定輸出陣列的格式：

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

當物件經過字串化時，預設會使用方括弧標記法：

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

您可將選項 `allowDots` 設定為 `true`，覆寫此選項以使用點標記法：

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

空字串和 Null 值會省略值，但等號 (=) 仍會保留：

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

沒有值的索引鍵 (例如空的物件或陣列) 不會傳回任何值：

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

設定為 `undefined` 的屬性將會完全省略：

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

查詢字串可能會選擇性地在前面加上問號：

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

也可以使用字串化覆寫分隔符號：

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

如果您只想覆寫 `Date` 物件的序列化，可提供 `serializeDate` 選項：

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

您可使用 `sort` 選項來影響參數索引鍵的順序：

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

最後，您可使用 `filter` 選項來限制字串化輸出將包含哪些索引鍵。
如果您傳遞函式，則會針對每個索引鍵呼叫函式，以取得取代值。 否則，如果您傳遞陣列，它將會用於選取屬性和陣列索引以進行字串化：

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>`null` 值的處理

根據預設，系統會將 `null` 值視為空字串：

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

剖析不會區分具有和不具有等號的參數。 兩者都會轉換成空字串。

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

若要區分 `null` 值和空字串，請使用 `strictNullHandling` 旗標。 在產生的字串中，`null` 值不具有任何 `=` 符號：

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

若要剖析值不具有 `=` 的值，請回到 `null`，使用 `strictNullHandling` 旗標：

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

若要完全略過帶有 `null` 值的轉譯索引鍵，請使用 `skipNulls` 旗標：

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

如果您希望與舊版系統通訊，可使用 `charset` 選項，切換為 `iso-8859-1`：

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

`iso-8859-1` 中不存在的字元會轉換成數值實體，類似瀏覽器執行的動作：

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

您可使用 `charsetSentinel` 選項來宣告字元，方法是包含適當編碼的 `utf8=✓` 參數，類似於 Ruby on Rails 和其他程式框架在提交表單時執行的動作。

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>處理特殊字元集

根據預設，字元的編碼和解碼會在 `utf-8` 完成，而 `iso-8859-1` 也會透過 `charset` 參數內建支援。

如果您想將查詢字串編碼為不同的字元集，(即 [Shift JIS](https://en.wikipedia.org/wiki/Shift_JIS))，可使用 [`qs-iconv`](https://github.com/martinheidegger/qs-iconv) 程式庫：

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

這也可用於解碼查詢字串：

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>RFC 3986 和 RFC 1738 空間編碼

RFC3986 為預設選項，可將 ' ' 編碼為向上相容的 *%20*。
同時，輸出可按照 RFC1738 進行字串化，其中 ' ' 等於 '+'。

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>安全性

若您需要回報潛在的安全漏洞，請傳送電子郵件至 [@ljharb](https://github.com/ljharb) 或查看 https://tidelift.com/security 。

## <a name="qs-for-enterprise"></a>適用於企業的 qs

可在 Tidelift 訂閱中取得

qs 和數千個其他套件的維護人員目前已與 Tide 合作，為您用於組建應用程式的開放原始碼相依性提供商業支援和維護服務。 透過付費取得相依性維護人員協助後，您可節省時間、降低風險並改善程式碼健康情況。 [深入了解。](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
