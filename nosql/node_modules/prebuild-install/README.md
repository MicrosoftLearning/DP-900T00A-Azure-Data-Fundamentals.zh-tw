---
ms.openlocfilehash: 50690c00791b1f6ca1d585c1fb653f0ec4794578
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050812"
---
# <a name="prebuild-install"></a>prebuild-install

> **命令列工具，可在特定平台上針對 Node.js & Electron 多個版本輕鬆安裝預先組件的二進位檔。**
> 根據預設，會從 GitHub 版本下載預先組建的二進位檔。

[![npm](https://img.shields.io/npm/v/prebuild-install.svg)](https://www.npmjs.com/package/prebuild-install)
![Node 版本](https://img.shields.io/node/v/prebuild-install.svg)
[![測試](https://github.com/prebuild/prebuild-install/actions/workflows/test.yml/badge.svg)](https://github.com/prebuild/prebuild-install/actions/workflows/test.yml)
[![david](https://david-dm.org/prebuild/prebuild-install.svg)](https://david-dm.org/prebuild/prebuild-install)
[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg)](http://standardjs.com/)

## <a name="note"></a>注意

**建議您將 [`prebuildify`](https://github.com/prebuild/prebuildify) 與 [`node-gyp-build`](https://github.com/prebuild/node-gyp-build) 配對，不要將 [`prebuild`](https://github.com/prebuild/prebuild) 與 [`prebuild-install`](https://github.com/prebuild/prebuild-install) 配對。**

使用 `prebuildify` 時，所有預先組建的二進位檔都隨附在發佈至 npm 的套件內，這表示您不需要像在 `prebuild` 中找到的步驟那樣，另外進行下載。 這個方法的矛盾之處在於：對所有平台來說，當二進位檔組成套件時，下載所有預先組建二進位檔的速度，會比下載作為安裝指令碼的單一預先組建二進位檔還快。

優點：

1. 無需額外進行下載，讓安裝程序變得更為可靠、快速。
2. 可在本機變更執行階段版本，並在 Node.js 與 Electron 之間採用相同的安裝步驟。 無需重新安裝或重建，因為所有預先組建的二進位檔都位於 npm tarball 中，而系統會在執行階段選出正確的二進位檔。
3. `node-gyp-build` 執行階段相依性並不具備相依性，因此原則上會維持不變，因為如果引入相依性，就無法縮短安裝時間。
4. 即使停用 npm 安裝指令碼，預先組建的二進位檔仍可運作。
5. npm 套件總和檢查碼也涵蓋預先組建的二進位檔。

缺點：

1. 已安裝的 npm 套件會占用較多的磁碟空間。 使用 [Node-API](https://nodejs.org/api/n-api.html) 有助於解決這個問題，因為 Node-API 二進位檔與執行階段無關，而且能向下相容。
2. 發佈上相對略為複雜，因為在編譯和擷取預先組建的二進位檔後 (通常在 CI 中)，必須完成 `npm publish`。

## <a name="usage"></a>使用方式

利用 [`prebuild`](https://github.com/prebuild/prebuild) 建立和上傳預先組建的二進位檔。 接著將 package.json 安裝指令碼變更為：

```json
{
  "scripts": {
    "install": "prebuild-install || node-gyp rebuild"
  }
}
```

### <a name="help"></a>說明

```
prebuild-install [options]

  --download    -d  [url]       (download prebuilds, no url means github)
  --target      -t  version     (version to install for)
  --runtime     -r  runtime     (Node runtime [node, napi or electron] to build or install for, default is node)
  --path        -p  path        (make a prebuild-install here)
  --token       -T  gh-token    (github token for private repos)
  --arch            arch        (target CPU architecture, see Node OS module docs, default is current arch)
  --platform        platform    (target platform, see Node OS module docs, default is current platform)
  --tag-prefix <prefix>         (github tag prefix, default is "v")
  --build-from-source           (skip prebuild download)
  --verbose                     (log verbosely)
  --libc                        (use provided libc rather than system default)
  --debug                       (set Debug or Release configuration)
  --version                     (print prebuild-install version and exit)
```

當您透過 `npm` 指令碼執行 `prebuild-install` 時，選項 `--build-from-source`、`--debug`、`--download`、`--target`、`--runtime`、`--arch` 和 `--platform` 會經由傳送至 `npm` 命令的引數傳遞。

或者，您可設定環境變數 `npm_config_build_from_source=true`、`npm_config_platform`、`npm_config_arch`、`npm_config_target` 和 `npm_config_runtime`。

### <a name="private-repositories"></a>私人存放庫

`prebuild-install` 可讓您從使用 `-T <github-token>` 的私人 GitHub 存放庫中下載預先組建檔案：

```
$ prebuild-install -T <github-token>
```

如果您不想在 cli 上使用權杖，可將它存放在 `~/.prebuild-installrc`：

```
token=<github-token>
```

或者，您可在 `prebuild-install_token` 環境變數中指定該權杖。

請注意：如果您使用 GitHub 權杖，系統會使用 API 來解析您必須遵守的正確版本意義 ([GitHub 速率限制](https://developer.github.com/v3/rate_limit/))。

### <a name="create-github-token"></a>建立 GitHub 權杖

若要建立權杖：

- 前往[此頁面](https://github.com/settings/tokens)
- 按一下 `Generate new token` 按鈕
- 為權杖命名，然後按一下 `Generate token` 按鈕，如下方所示

![prebuild-token](https://cloud.githubusercontent.com/assets/13285808/20844584/d0b85268-b8c0-11e6-8b08-2b19522165a9.png)

預設範圍應該沒有問題。

### <a name="custom-binaries"></a>自訂二進位檔

終端使用者可透過 .npmrc 檔案中的環境變數覆寫二進位檔的下載位置。
變數必須與遮罩 `% your package name %_binary_host` 或 `% your package name %_binary_host_mirror` 相符。 例如：

```
leveldown_binary_host=http://overriden-host.com/overriden-path
```

請注意：仍會在套件版本中附加子路徑和檔案名稱。
因此，如果您正在安裝 `leveldown@1.2.3`，產生的 URL 會是：

```
http://overriden-host.com/overriden-path/v1.2.3/leveldown-v1.2.3-node-v57-win32-x64.tar.gz
```

#### <a name="local-prebuilds"></a>本機預先組建

如果您想使用本機檔案系統的預先組建檔案，可使用 `% your package name %_local_prebuilds` .npmrc 變數來為包含預先組建檔案的資料夾設定路徑。 例如：

```
leveldown_local_prebuilds=/path/to/prebuilds
```

此選項會直接在該資料夾中查看使用 `prebuild` 建立的套件組合，例如：

```
/path/to/prebuilds/leveldown-v1.2.3-node-v57-win32-x64.tar.gz
```

針對叫用 prebuild-install 的套件目錄，非完整路徑會解析與該目錄的相關性，例如巢狀相依性。

### <a name="cache"></a>快取

系統會快取所有預先組建的二進位檔，以降低流量。 因此，`prebuild-install` 會先從快取中挑選二進位檔。如果沒有可以選擇的二進位檔，便會進行下載。 系統會依環境，根據以下順序決定快取資料夾：

- `${npm_config_cache}/_prebuilds`
- `${APP_DATA}/npm-cache/_prebuilds`
- `${HOME}/.npm/_prebuilds`

## <a name="license"></a>授權

MIT
