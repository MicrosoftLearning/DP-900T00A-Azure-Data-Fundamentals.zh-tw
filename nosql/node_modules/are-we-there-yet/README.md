---
ms.openlocfilehash: 34b661fbb1237d51bdab932626d19518225841a0
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050939"
---
<a name="are-we-there-yet"></a>are-we-there-yet
----------------

追蹤非同步工作完成狀態的複雜階層，  目的是提供一個方法，讓您記錄和報告大型遞迴展開傳送的進度，以及收集非同步作業中相當常見的類型工作流程。

您可以自行決定如何處理這些完成資料，不過最常見的使用案例是將這些資料饋送至其中一個進度列模組。

大多數進度列模組都包含這類資料的基本版本，不過我當時的需求比較複雜。

<a name="usage"></a>使用方式
=====

```javascript
var TrackerGroup = require("are-we-there-yet").TrackerGroup

var top = new TrackerGroup("program")

var single = top.newItem("one thing", 100)
single.completeWork(20)

console.log(top.completed()) // 0.2

fs.stat("file", function(er, stat) {
  if (er) throw er  
  var stream = top.newStream("file", stat.size)
  console.log(top.completed()) // now 0.1 as single is 50% of the job and is 20% complete
                              // and 50% * 20% == 10%
  fs.createReadStream("file").pipe(stream).on("data", function (chunk) {
    // do stuff with chunk
  })
  top.on("change", function (name) {
    // called each time a chunk is read from "file"
    // top.completed() will start at 0.1 and fill up to 0.6 as the file is read
  })
})
```

<a name="shared-methods"></a>分享方法
==============

* var completed = tracker.completed()

實作於：`Tracker`、`TrackerGroup`、`TrackerStream`

傳回已完成工作與須完成工作的比例， 範圍為 0 至 1。

* tracker.finish()

實作於：`Tracker`、`TrackerGroup`

將追蹤器標記為已完成。 如使用 TrackerGroup 則會將追蹤器的所有元件標記為已完成。

將追蹤器的所有元件標記為已完成，因此 `tracker.completed()` 會為 1。

這會發出一或多個 `change` 事件。

<a name="events"></a>事件
======

所有追蹤器物件都會發出含有下列引數的 `change` 事件：

```
function (name, completed, tracker)
```

`name` 為原先發出事件的追蹤器的名稱。假如該追蹤器沒有名稱，則為第一個包含追蹤器群組的已命名追蹤器的名稱。

`completed` 為完成百分比 (由 `tracker.completed()` 方法傳回)。

`tracker` 為您接聽的事件所屬的追蹤器物件。

<a name="trackergroup"></a>TrackerGroup
============

* var tracker = new TrackerGroup(**name**)

  * **name** (選用)：此追蹤器群組的名稱。如更新的元件沒有名稱，變更通知就會使用這個名稱。 預設為未定義。

建立新的空白追蹤器彙總群組。 這些追蹤器的完成狀態取決於其他追蹤器的完成狀態。

* tracker.addUnit(**otherTracker**, **weight**)

  * **otherTracker**：所有其他 are-we-there-yet 追蹤器物件
  * **weight** (選用)：追蹤器的權數，預設為 1。

將 **otherTracker** 新增至這個彙總群組。 此權數用於決定您希望此追蹤器與其他單元相比，須花費多少完成時間。  舉例來說，如果您將一個追蹤器的權數設為 1，另一個設為 2，就表示您希望第二個追蹤器的完成時間為第一個的兩倍長，  因此第一個會占追蹤器完成時間的 33% ，第二個則會占剩下的 67%。

傳回 **otherTracker**。

* var subGroup = tracker.newGroup(**name**, **weight**)

以上完全等同於：

```javascript
  var subGroup = tracker.addUnit(new TrackerGroup(name), weight)
```

* var subItem = tracker.newItem(**name**, **todo**, **weight**)

以上完全等同於：

```javascript
  var subItem = tracker.addUnit(new Tracker(name, todo), weight)
```

* var subStream = tracker.newStream(**name**, **todo**, **weight**)

以上完全等同於：

```javascript
  var subStream = tracker.addUnit(new TrackerStream(name, todo), weight)
```

* console.log( tracker.debug() )

傳回一個樹狀結構，顯示此追蹤群組及其所有子項目的完成狀態，包含遞迴輸入所有子項目。

<a name="tracker"></a>Tracker
=======

* var tracker = new Tracker(**name**, **todo**)

  * **name** (選用) 要在變更事件內回報的計數器名稱，  預設為未定義。
  * **todo** (選用) 須完成的工作量 (數字)， 預設為 0。

一般而言，這些會建構為追蹤群組的一部份 (透過 `newItem`)。

* var completed = tracker.completed()

傳回已完成工作與須完成工作的比例， 範圍為 0 至 1。 如果須完成的總工作量為 0，則傳回 0。

* tracker.addWork(**todo**)

  * **todo** 要加入須完成工作量的數字。

須完成工作量增加，因此完成百分比會降低。  會觸發 `change` 事件。

* tracker.completeWork(**completed**)

  * **completed** 要加入已完成工作量的數字

完成工作量增加，因此完成百分比會提高。
已完成工作量增加後，絕不會比須完成工作量更多， 也就是不允許百分比 > 100%。 會觸發 `change` 事件。

* tracker.finish()

將此追蹤器標示為已完成，tracker.completed() 為 1。 會觸發 `change` 事件。

<a name="trackerstream"></a>TrackerStream
=============

* var tracker = new TrackerStream(**name**, **size**, **options**)

  * **name** (選用) 要在變更事件內回報的計數器名稱，  預設為未定義。
  * **size** (選用) 透過此資料流傳送的位元組數。
  * **options** (選用) 資料流選項的雜湊

追蹤器資料流物件是傳遞資料流，每當一個區塊經過就會更新內部追蹤器物件，  目的是追蹤下載數、檔案擷取和其他相關活動。 您可以將資料來源透過管道傳送至這個物件，然後將此物件當作您的資料來源。

如果您的資料有長度屬性，當區塊經過時，會將該屬性當作已完成工作量來使用；  假如沒有 (如物件資料流)，則會將每個經過的區塊計為 1 單位的已完成工作，因此大小會是串流處理的物件總數。

* tracker.addWork(**todo**)

  * **todo** 增加 **todo** 位元組的預期總大小。

須完成工作量增加，因此完成百分比會降低。  會觸發 `change` 事件。
