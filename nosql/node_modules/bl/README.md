---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050652"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![組建狀態](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Node.js 緩衝區清單收集器、讀取器和串流器。**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** 是 Node Buffers 集合的儲存物件，公開提供用於讀取主要緩衝區的 API。 您也可以採用雙工方式處理資料流，讓您能同時從資料流收集緩衝區，並將緩衝區發回資料流來消耗它們！

不會更動原始緩衝區，並視需要在複本上進行作業。 如需讀取單一原始緩衝區時，只會傳回該緩衝區的一部份配量 (該配量與原始緩衝區指向相同記憶體位址)。 跨越緩衝區的讀取會視需要執行串連，並將結果以透明方式傳回。

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

在建構函式中提供回呼，其使用方法與 **[concat-stream](https://github.com/maxogden/node-concat-stream)** 相同：

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

請注意，當您使用類似於此的回呼方法，所產生的 `data` 參數是清單中所有 `Buffer` 物件的串連。 如果您想避免這種造成額外負荷的串連 (尤其是極度追求效能時)，請避免使用回呼方法，並如標準串流的方式，改為接聽 `'end'`。

或者使用 [hyperquest](https://github.com/substack/hyperquest) 擷取 URL (需配合 [request](http://github.com/mikeal/request) 乃至於一般的 Node HTTP 模組一起使用！)：

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

或者，將它視為可讀取的資料流來使用，將緩衝區清單重新編排至輸出來源：

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer 陣列 | BufferList | BufferList 陣列 | String ])
此建構函式不需要任何引數，但您可以傳入單一 `Buffer` 物件或 `Buffer` 物件的陣列，以初始化清單。

並非一定要使用 `new` 進行初始化，如果您尚未將新的物件具現化，它會自動為您完成，因此您也可以透過以下方式輕鬆建立新的執行個體：

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
判斷傳遞的物件是否為 `BufferList`。 如果傳遞的物件是 `BufferList` **或** `BufferListStream` 的執行個體，則會傳回 `true`；否則會傳回 `false`。

特別注意： 在新增此靜態方法前，即使判斷出以此程式庫版本建立的 `BufferList` 或 `BufferListStream` 執行個體，也不會傳回 `true`。

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
取得清單的長度 (以位元組為單位)。 此為清單中所包含的緩衝區長度總和，且已預設扣除已消耗緩衝區的初始位移值。 理論上能正確表示可以從清單中讀取的位元組總數目。

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer 陣列 | BufferList | BufferList 陣列 | String)
`append(buffer)` 能將額外的緩衝區或 BufferList 新增至內部清單。 並將 `this` 傳回，因此也可用於鏈結。

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(索引值)
`get()` 能傳回指定索引值所指向的位元組。

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` 能傳回指定索引值所指向的位元組。
`indexOf()` 方法會傳回能在 BufferList 中找到第一個已知元素的索引值，如果未找到則會傳回 -1。

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` 會傳回新的 `Buffer` 物件，其中包含指定範圍內的位元組。 `start` 和 `end` 均為可設定選項，如果未指定則會分別預設為該清單的開頭和結尾。

如果指定範圍並未逾越單一內部緩衝區，則會傳回該緩衝區的配量，且該配量與其涵蓋範圍的緩衝區共用相同原始記憶體位址。 如果範圍跨越多個緩衝區，則會複製指定範圍的緩衝區，並提供給您整合為一體的緩衝區。

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` 會傳回新的 `BufferList` 物件，其中包含指定範圍內的位元組。 `start` 和 `end` 均為可設定選項，如果未指定則會分別預設為該清單的開頭和結尾。

此函式不會複製任何緩衝區。 所有結果中的緩衝區，都會與原始清單共用記憶體位址。

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` 會複製 `dest` 緩衝區清單中的內容，從 `destStart` 開始，包含 `srcStart` 與 `srcEnd` 之間指定範圍內的位元組。 `destStart`、`start` 和 `end` 均為可設定選項，如果未指定則會分別預設為 `dest` 緩衝區的開頭，以及該清單的開頭和結尾。

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` 會對該清單執行 **淺層複製 (Shallow Copy)** 。 內部緩衝區會維持不變，因此如果您變更底層緩衝區，變更將會同時反映至原始和複製的緩衝區。 如果您想要呼叫 `consume()` 或 `pipe()`，但同時保留原始清單，則建議使用此方法，其範例如下：

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(位元組)
`consume()` 會從清單開頭移位位元組。 消耗的位元組數量不需與內部緩衝區的大小一致，函式會自動根據初始位移值進行計算，以提供您具一致性的資料檢視。

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` 會以字串呈現的方式傳回緩衝區。 `start` 和 `end` 為可設定的引數，用於傳遞至 `slice()`，而 `encoding` 則會傳遞至結果緩衝區的 `toString()`。 如需詳細資訊，請參閱有關 [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end) 的文件。

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE()、bl.readDoubleLE()、bl.readFloatBE()、bl.readFloatLE()、bl.readInt32BE()、bl.readInt32LE()、bl.readUInt32BE()、bl.readUInt32LE()、bl.readInt16BE()、bl.readInt16LE()、bl.readUInt16BE()、bl.readUInt16LE()、bl.readInt8()、bl.readUInt8()

提供所有標準位元組讀取方法，均可用於 `Buffer` 介面，且能以透明方式橫跨內部緩衝區界限進行作業。

請參閱 <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b> 相關文件，以了解其使用方式。

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ 回呼 | Buffer | Buffer 陣列 | BufferList | BufferList 陣列 | String ])
**BufferListStream** 是 Node 的 **[雙工串流函式 (Duplex Stream)](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** ，因此可以同時讀取和寫入資料流，就像標準 Node 資料流一樣。 您也可以使用 `pipe()`，以管線方式讀取和寫入 **BufferListStream** 執行個體。

您可選擇為此建構函式設定回呼函式，如果事先提供回呼函式，當 `bl.end()` 被呼叫時 (例如收到管線資料流的呼叫)，建構函式會以錯誤引數呼叫回呼函式，並將參考值傳遞給 **bl** 執行個體。 這是收集完整資料流內容的好方法，尤其在資料流很 *臃腫* 的情況下更加便利，例如網路資料流。

一般來說，建構函式不需要任何引數，但您可以透過傳入單一 `Buffer` 物件或 `Buffer` 物件的陣列，以初始化清單。

並非一定要使用 `new` 進行初始化，如果您尚未將新的物件具現化，它會自動為您完成，因此您也可以透過以下方式輕鬆建立新的執行個體：

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

特別注意： 基於對回溯相容性的考量，當您使用 `require('bl')` 時，`BufferListStream` **預設** 為匯出：

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>參與者

**bl** 由以下駭客協助開發：

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>授權&amp;著作權

(c) 2013-2019 bl 參與者 (列於上方) 著作權所有。

bl 根據 MIT 授權進行授權。 未於 MIT 授權中明確授予的權利也全部予以保留。 如需詳細資訊，請參閱內含的 LICENSE.md 檔案。
